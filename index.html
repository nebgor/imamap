<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Perth PT Commute Sketch</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <link
    rel="icon"
    href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="%230c172a"/><path d="M16 40c8-12 24-12 32 0" stroke="%237bdcb5" stroke-width="5" fill="none" stroke-linecap="round"/><circle cx="32" cy="24" r="6" fill="%2364b5ff"/></svg>'
  />
  <style>
    :root {
      --panel-bg: rgba(12, 16, 27, 0.9);
      --panel-text: #eaf3ff;
      --accent: #6fe7c9;
      --muted: #9fb1c7;
      --border: rgba(255, 255, 255, 0.14);
      --font: "Inter", system-ui, -apple-system, sans-serif;
      --rail: #64b5ff;
      --bg-1: #0b1020;
      --bg-2: #0f1a32;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at 35% 25%, #10213f 0%, #0b1228 50%, #080c1a 100%);
      font-family: var(--font);
      color: var(--panel-text);
      overflow: hidden;
    }
    #map {
      position: absolute;
      inset: 0;
      z-index: 0;
    }
    .panel {
      position: absolute;
      top: 14px;
      left: 14px;
      width: 340px;
      max-height: 90vh;
      overflow-y: auto;
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(6px);
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.22);
      z-index: 1200;
    }
    h1 {
      margin: 0 0 10px;
      font-size: 17px;
      letter-spacing: 0.4px;
      font-weight: 700;
      color: #e0fbff;
    }
    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .row label {
      flex: 1;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.06);
      color: var(--panel-text);
      font-size: 14px;
    }
    select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.06);
      color: var(--panel-text);
      font-size: 14px;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      font-size: 13px;
      color: var(--muted);
      flex-wrap: wrap;
    }
    button {
      padding: 8px 12px;
      border-radius: 10px;
      border: none;
      font-weight: 700;
      letter-spacing: 0.2px;
      background: linear-gradient(120deg, #4dd4a4, #5fb3ff);
      color: #04131e;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.18);
    }
    button:active {
      transform: translateY(1px);
    }
    .legend {
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
    }
    .btn-compact {
      flex: 1 1 calc(50% - 8px);
      min-width: 140px;
    }
    .btn-tiny {
      padding: 6px 10px;
      font-size: 12px;
    }
    .legend-bar {
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(
        90deg,
        hsl(120, 75%, 45%),
        hsl(60, 80%, 52%),
        hsl(30, 85%, 55%),
        hsl(0, 80%, 50%)
      );
      border: 1px solid var(--border);
      margin: 6px 0 4px;
    }
    .legend-scale {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--muted);
    }
    .mode-legend {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 6px;
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .busy-banner {
      position: fixed;
      top: 10px;
      right: 14px;
      padding: 8px 12px;
      border-radius: 10px;
      background: rgba(12, 16, 27, 0.9);
      border: 1px solid var(--border);
      color: #eaf3ff;
      font-size: 12px;
      z-index: 1500;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    }
    .hidden {
      display: none;
    }
    @media (max-width: 700px) {
      .panel {
        width: calc(100% - 20px);
        left: 10px;
        right: 10px;
      }
    }
    .mode-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
    }
    .mode-swatch {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.3);
      flex-shrink: 0;
    }
    .status {
      font-size: 12px;
      color: var(--muted);
    }
    .debug {
      position: absolute;
      bottom: 12px;
      left: 14px;
      background: rgba(8, 11, 20, 0.9);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      max-width: 460px;
      font-size: 12px;
      color: #cbd5e1;
      display: grid;
      gap: 4px;
      line-height: 1.4;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
      z-index: 1200;
    }
    .debug strong {
      color: #e2f3ff;
    }
    .rail-label {
      background: rgba(15, 102, 175, 0.5);
      color: #e7f6ff;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    .gallery {
      margin-top: 8px;
      border-top: 1px solid var(--border);
      padding-top: 8px;
      display: grid;
      gap: 6px;
    }
    .gallery h2 {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
    }
    .snapshots {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }
    .snapshot-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px;
      display: grid;
      gap: 4px;
    }
    .snapshot-card img {
      width: 100%;
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .snapshot-card button {
      width: 100%;
      padding: 6px 8px;
      background: rgba(255, 255, 255, 0.08);
      color: #d7e6ff;
      border-radius: 8px;
      font-weight: 600;
      box-shadow: none;
    }
    .snapshot-meta {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
    }
    @media (max-width: 600px) {
      .panel {
        width: calc(100% - 24px);
        left: 12px;
        right: 12px;
      }
      .row {
        flex-direction: column;
      }
      .debug {
        max-width: calc(100% - 24px);
        left: 12px;
        right: 12px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="busyBanner" class="busy-banner hidden">Loading…</div>
  <button id="panelToggle" class="busy-banner" style="left:14px; right:auto; top:auto; bottom:12px;">Toggle panel</button>
  <div class="panel">
    <h1>Perth PT commute sketch</h1>
    <div class="row">
      <label>Base wait (min)
        <input type="number" id="baseWait" value="8" min="0" step="1" />
      </label>
      <label>Headway (min)
        <select id="headway">
          <option value="6">peak 6</option>
          <option value="10" selected>interpeak 10</option>
          <option value="15">off-peak 15</option>
        </select>
      </label>
      <label>Scenario
        <select id="scenarioPreset">
          <option value="custom" selected>custom</option>
          <option value="peak">peak</option>
          <option value="interpeak">interpeak</option>
          <option value="night">night</option>
        </select>
      </label>
    </div>
    <div class="row">
      <label>Mode
        <select id="modePref">
          <option value="mixed">mixed</option>
          <option value="bus">bus only</option>
          <option value="rail">rail only</option>
          <option value="car">car</option>
        </select>
      </label>
      <label>Transfer
        <select id="allowTransfer">
          <option value="true">enabled</option>
          <option value="false">disabled</option>
        </select>
      </label>
      <label>Random wait
        <select id="randomWait">
          <option value="true" selected>on</option>
          <option value="false">off</option>
        </select>
      </label>
    </div>
    <div class="row">
      <label>Bus speed (km/h)
        <input type="number" id="busSpeed" value="40" min="5" step="5" />
      </label>
      <label>Rail speed (km/h)
        <input type="number" id="railSpeed" value="65" min="10" step="5" />
      </label>
      <label>Car speed (km/h)
        <input type="number" id="carSpeed" value="70" min="10" step="5" />
      </label>
    </div>
    <div class="controls" style="flex-wrap: wrap;">
      <button class="btn-compact" id="simulateRandom">Random sim</button>
      <button class="btn-compact" id="radialSim">Radial sims</button>
      <button class="btn-compact" id="rushSim">CBD rush</button>
      <button class="btn-compact" id="rainSim">Rain</button>
      <button class="btn-compact" id="demoRun">Demo</button>
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="keepVisuals" />
        Keep visuals
      </label>
    </div>
    <div class="controls">
      <button class="btn-compact btn-tiny" id="recompute">Recompute</button>
      <button class="btn-compact btn-tiny" id="saveSnapshot">Snapshot</button>
      <button class="btn-compact btn-tiny" id="clearVisuals">Clear visuals</button>
      <button class="btn-compact btn-tiny" id="clearCaches">Reset caches</button>
    </div>
    <div class="controls">
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="toggleStops" checked />
        Stops
      </label>
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="toggleRail" checked />
        Rail
      </label>
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="toggleRoads" />
        Roads
      </label>
    </div>
    <div class="row">
      <label>Suburb experiment
        <select id="presetSelect">
          <option value="scarborough">Scarborough</option>
          <option value="joondalup">Joondalup</option>
          <option value="fremantle">Fremantle</option>
          <option value="midland">Midland</option>
          <option value="armadale">Armadale</option>
          <option value="ellenbrook">Ellenbrook</option>
        </select>
      </label>
      <label style="align-self:flex-end;">
        <button id="runPreset">Run preset</button>
      </label>
    </div>
    <div class="legend">
      Commute minutes
      <div class="legend-bar"></div>
      <div class="legend-scale">
        <span>short</span><span>medium</span><span>long</span>
      </div>
    </div>
    <div class="mode-legend" aria-label="Routing mode colors">
      <span class="mode-chip"><span class="mode-swatch" style="background:#22c55e"></span>Bus graph</span>
      <span class="mode-chip"><span class="mode-swatch" style="background:#0ea5e9"></span>Bus → rail</span>
      <span class="mode-chip"><span class="mode-swatch" style="background:#10b981"></span>Mixed transfer</span>
      <span class="mode-chip"><span class="mode-swatch" style="background:#38bdf8"></span>Rail</span>
      <span class="mode-chip"><span class="mode-swatch" style="background:#f59e0b"></span>Bus direct</span>
      <span class="mode-chip"><span class="mode-swatch" style="background:#a855f7"></span>Car</span>
      <span class="mode-chip"><span class="mode-swatch" style="background:#ef4444"></span>Fallback</span>
    </div>
    <div class="status" id="status">Fetching stops…</div>
    <div class="gallery">
      <h2>Snapshots (cached locally)</h2>
      <div class="snapshots" id="snapshots"></div>
    </div>
  </div>
  <div class="debug" id="debug">
    <div><strong>Debug</strong> — ready</div>
    <div id="debug-meta"></div>
    <div id="debug-corridor"></div>
    <div id="debug-path"></div>
  </div>
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script
    src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"
    integrity="sha256-65UqrlgGoRAnKfKRuriH3eeDrOhZgZo1SCenduc+SGo="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
  <script>
    function buildRouteGraph(routes) {
      const nodes = new Map();
      const key = (lat, lon) => `${lat.toFixed(5)},${lon.toFixed(5)}`;
      function addEdge(a, b) {
        const ka = key(a[0], a[1]);
        const kb = key(b[0], b[1]);
        const d = haversine(a[0], a[1], b[0], b[1]);
        if (!nodes.has(ka)) nodes.set(ka, { lat: a[0], lon: a[1], edges: [] });
        if (!nodes.has(kb)) nodes.set(kb, { lat: b[0], lon: b[1], edges: [] });
        nodes.get(ka).edges.push({ k: kb, w: d });
        nodes.get(kb).edges.push({ k: ka, w: d });
      }
      routes.forEach((r) => {
        (r.paths || []).forEach((path) => {
          for (let i = 0; i < path.length - 1; i++) {
            addEdge(path[i], path[i + 1]);
          }
        });
      });
      return { nodes, routes };
    }

    function shortestPath(graph, start, goal, goalOverrideKey) {
      const nodes = graph.nodes;
      const startKey = nearestNodeKey(nodes, start.lat, start.lon);
      const goalKey = goalOverrideKey || nearestNodeKey(nodes, goal.lat, goal.lon);
      if (!startKey || !goalKey) return null;
      const dist = new Map();
      const prev = new Map();
      const pq = [];
      function push(k, d) {
        pq.push({ k, d });
        pq.sort((a, b) => a.d - b.d);
      }
      nodes.forEach((_, k) => dist.set(k, Infinity));
      dist.set(startKey, 0);
      push(startKey, 0);
      while (pq.length) {
        const { k } = pq.shift();
        if (k === goalKey) break;
        const n = nodes.get(k);
        if (!n) continue;
        n.edges.forEach((e) => {
          const alt = dist.get(k) + e.w;
          if (alt < dist.get(e.k)) {
            dist.set(e.k, alt);
            prev.set(e.k, k);
            push(e.k, alt + heuristic(nodes.get(e.k), nodes.get(goalKey)));
          }
        });
      }
      if (!prev.has(goalKey) && startKey !== goalKey) return null;
      const path = [];
      let u = goalKey;
      path.unshift(nodes.get(u));
      while (prev.has(u)) {
        u = prev.get(u);
        path.unshift(nodes.get(u));
      }
      return path.map((p) => [p.lat, p.lon]);
    }

    function heuristic(a, b) {
      return haversine(a.lat, a.lon, b.lat, b.lon);
    }

    function nearestNodeKey(nodes, lat, lon) {
      let best = null;
      let bestD = Infinity;
      nodes.forEach((v, k) => {
        const d = haversine(lat, lon, v.lat, v.lon);
        if (d < bestD) {
          bestD = d;
          best = k;
        }
      });
      return best;
    }
  </script>
  <script>
    const qs = new URLSearchParams(window.location.search);
    if (qs.get("status") === "json") {
      const heatLen = (() => {
        try {
          const v = localStorage.getItem("simHeatV1");
          return v ? JSON.parse(v).length : 0;
        } catch {
          return 0;
        }
      })();
      const stopLen = (() => {
        try {
          const v = localStorage.getItem("stopsCacheV1");
          if (!v) return 0;
          const p = JSON.parse(v);
          return (p.stops || []).length;
        } catch {
          return 0;
        }
      })();
      document.body.innerHTML = `<pre>${JSON.stringify(
        {
          status: "ok",
          timestamp: new Date().toISOString(),
          heatCount: heatLen,
          stopCacheCount: stopLen,
          dataSource: typeof DATA_SOURCE === "undefined" ? "unknown" : DATA_SOURCE,
          fallbackStops:
            typeof FALLBACK_STOPS === "undefined"
              ? 0
              : (FALLBACK_STOPS.busStops.length || 0) + (FALLBACK_STOPS.railStops.length || 0),
          note: "status-only mode; map not initialized"
        },
        null,
        2
      )}</pre>`;
      throw new Error("status-only-mode");
    }

    const target = { lat: -31.9523, lon: 115.8590 };
    let DATA_SOURCE = "unknown";
    const MODE_COLORS = {
      "bus-graph": "#22c55e",
      "bus-rail": "#0ea5e9",
      "mixed-transfer": "#10b981",
      rail: "#38bdf8",
      bus: "#f59e0b",
      car: "#a855f7",
      fallback: "#ef4444",
      auto: "#22c55e"
    };
    const PRESETS = {
      scarborough: { name: "Scarborough", lat: -31.894, lon: 115.751 },
      joondalup: { name: "Joondalup", lat: -31.744, lon: 115.768 },
      fremantle: { name: "Fremantle", lat: -32.053, lon: 115.748 },
      midland: { name: "Midland", lat: -31.889, lon: 116.005 },
      armadale: { name: "Armadale", lat: -32.153, lon: 116.016 },
      ellenbrook: { name: "Ellenbrook", lat: -31.776, lon: 115.97 }
    };
    let PROPERTY_DATA = [];
    async function loadLocalFallbackStops() {
      try {
        const [busRes, railRes] = await Promise.all([
          fetch("data/fallback-bus-stops.json"),
          fetch("data/fallback-rail-stops.json")
        ]);
        if (!busRes.ok || !railRes.ok) throw new Error("fallback file missing");
        const [bus, rail] = await Promise.all([busRes.json(), railRes.json()]);
        const merged = [...bus, ...rail].filter((s) => s.lat && s.lon);
        if (merged.length) return merged;
        throw new Error("empty fallback files");
      } catch (err) {
        lastError = err.message || "fallback read failed";
        return null;
      }
    }
    const SAMPLE_STOPS = [
      { stopid: "CBD", stopname: "Perth Station", lat: -31.9516, lon: 115.8605 },
      { stopid: "EQ", stopname: "Elizabeth Quay", lat: -31.9563, lon: 115.8543 },
      { stopid: "MUR", stopname: "Murdoch", lat: -32.071, lon: 115.85 },
      { stopid: "CBK", stopname: "Cockburn Central", lat: -32.1267, lon: 115.85 },
      { stopid: "LEED", stopname: "Leederville", lat: -31.9361, lon: 115.8414 },
      { stopid: "BUT", stopname: "Butler", lat: -31.639, lon: 115.71 },
      { stopid: "SUBI", stopname: "Subiaco", lat: -31.95, lon: 115.817 },
      { stopid: "BAY", stopname: "Bayswater", lat: -31.9147, lon: 115.9136 },
      { stopid: "GOS", stopname: "Gosnells", lat: -32.079, lon: 115.999 },
      { stopid: "FREO", stopname: "Fremantle", lat: -32.053, lon: 115.748 },
      { stopid: "SCA", stopname: "Scarborough Beach", lat: -31.894, lon: 115.751 },
      { stopid: "SCB", stopname: "Scarborough Beach Rd / West Coast", lat: -31.896, lon: 115.758 },
      { stopid: "INN", stopname: "Innaloo Bus Station", lat: -31.892, lon: 115.793 },
      { stopid: "GLD", stopname: "Glendalough Station", lat: -31.917, lon: 115.84 },
      { stopid: "WARW", stopname: "Warwick Station", lat: -31.8592, lon: 115.807 },
      { stopid: "JND", stopname: "Joondalup", lat: -31.744, lon: 115.768 }
    ];
    const STOP_CACHE_KEY = "stopsCacheV1";
    const SNAPSHOT_CACHE_KEY = "snapshotsV1";
    const STOP_CACHE_MAX_AGE_HRS = 6;
    const ROUTE_CACHE_KEY = "routesCacheV2";
    const ROUTE_CACHE_MAX_AGE_HRS = 12;
    let MODE_PREF = "mixed";
    let ALLOW_TRANSFER = true;
    let BUS_SPEED = 40;
    let RAIL_SPEED = 65;
    let CAR_SPEED = 70;
    let HEADWAY_MIN = 10;
    let RANDOM_WAIT = true;
    let DATA_READY = false;
    let ERROR_COUNT = 0;
    let busGraph = null;
    let railGraph = null;
    const rand = () => {
      if (crypto && crypto.getRandomValues) {
        const buf = new Uint32Array(1);
        crypto.getRandomValues(buf);
        return buf[0] / 2 ** 32;
      }
      return Math.random();
    };
    const map = L.map("map", { zoomControl: false, preferCanvas: true }).setView([target.lat, target.lon], 11);
    L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors & Carto'
    }).addTo(map);
    L.control.zoom({ position: "bottomright" }).addTo(map);

    const stopsLayer = L.layerGroup().addTo(map);
    const railLayer = L.layerGroup().addTo(map);
    const stationLayer = L.layerGroup().addTo(map);
    const simRootLayer = L.layerGroup().addTo(map);
    const roadsLayer = L.layerGroup();
    let stopsHiddenForZoom = false;
    let heatHiddenForZoom = false;
    let roadsHiddenForZoom = false;
    let simTimers = [];
    const heatLineLayer = L.layerGroup().addTo(map);
    const heatVisLayer = L.heatLayer([], {
      radius: 18,
      blur: 12,
      maxZoom: 17,
      gradient: { 0.1: "#1e3a8a", 0.4: "#22d3ee", 0.7: "#facc15", 1.0: "#ef4444" }
    }).addTo(map);
    let simTimer = null;
    let routeGraph = null;

    const corridors = [
      // Mandurah line corridor
      [[-31.95, 115.86], [-32.0, 115.86], [-32.1, 115.86], [-32.18, 115.83], [-32.25, 115.8], [-32.35, 115.78], [-32.45, 115.75]],
      // Joondalup / Yanchep
      [[-31.95, 115.86], [-31.9, 115.84], [-31.83, 115.8], [-31.74, 115.75], [-31.63, 115.71], [-31.55, 115.7], [-31.48, 115.7]],
      // Fremantle
      [[-31.95, 115.86], [-31.99, 115.84], [-32.03, 115.8], [-32.05, 115.78]],
      // Midland
      [[-31.95, 115.86], [-31.92, 115.9], [-31.89, 115.95], [-31.87, 116.0], [-31.88, 116.05]],
      // Armadale / Thornlie
      [[-31.95, 115.86], [-32.0, 115.88], [-32.04, 115.92], [-32.08, 115.98], [-32.12, 116.02]],
      // Airport
      [[-31.95, 115.86], [-31.93, 115.89], [-31.92, 115.96], [-31.93, 116.0]],
      // Ellenbrook
      [[-31.95, 115.86], [-31.89, 115.91], [-31.85, 115.94], [-31.82, 115.97], [-31.78, 115.98]]
    ];

    const railLines = [
      {
        name: "Mandurah",
        points: [
          [-31.95, 115.86],
          [-31.97, 115.86],
          [-31.986, 115.857], // Elizabeth Quay
          [-32.021, 115.857], // South Perth-ish alignment
          [-32.049, 115.851], // Canning Bridge
          [-32.062, 115.849], // Bull Creek
          [-32.071, 115.848], // Murdoch
          [-32.103, 115.85], // Cockburn approach
          [-32.127, 115.85], // Cockburn Central
          [-32.15, 115.846], // Success
          [-32.175, 115.842], // Aubin Grove
          [-32.205, 115.834], // Kwinana industrial curve
          [-32.249, 115.822], // Rockingham
          [-32.279, 115.781], // Warnbro
          [-32.32, 115.766], // Karnup/Lakelands curve
          [-32.37, 115.754],
          [-32.45, 115.747] // Mandurah
        ]
      },
      {
        name: "Joondalup/Yanchep",
        points: [
          [-31.95, 115.86],
          [-31.936, 115.846], // Leederville
          [-31.917, 115.84], // Glendalough
          [-31.897, 115.81], // Stirling
          [-31.866, 115.8], // Warwick
          [-31.844, 115.782], // Greenwood
          [-31.819, 115.768], // Whitfords
          [-31.78, 115.756], // Edgewater
          [-31.746, 115.742], // Joondalup
          [-31.728, 115.735], // Currambine
          [-31.712, 115.732], // Clarkson
          [-31.689, 115.73], // Butler
          [-31.64, 115.71], // Alkimos
          [-31.58, 115.69], // Eglinton
          [-31.52, 115.69], // interim curve
          [-31.48, 115.7] // Yanchep
        ]
      },
      {
        name: "Fremantle",
        points: [
          [-31.95, 115.86],
          [-31.958, 115.853], // City West
          [-31.964, 115.842], // West Leederville
          [-31.97, 115.829], // Subi
          [-31.989, 115.79], // Claremont
          [-32.009, 115.756], // Cottesloe
          [-32.033, 115.752],
          [-32.053, 115.748] // Fremantle
        ]
      },
      {
        name: "Midland",
        points: [
          [-31.95, 115.86],
          [-31.948, 115.872], // McIver/Claisebrook
          [-31.94, 115.885],
          [-31.93, 115.9],
          [-31.914, 115.914], // Bayswater
          [-31.9, 115.967], // Guildford
          [-31.889, 116.005] // Midland
        ]
      },
      {
        name: "Armadale/Thornlie",
        points: [
          [-31.95, 115.86],
          [-31.961, 115.894], // Burswood
          [-31.98, 115.897], // Oats St
          [-32.0, 115.92],
          [-32.04, 115.93],
          [-32.061, 115.952], // Thornlie spur
          [-32.079, 115.999], // Gosnells
          [-32.12, 116.02] // Armadale approach
        ]
      },
      {
        name: "Airport",
        points: [
          [-31.95, 115.86],
          [-31.941, 115.882],
          [-31.93, 115.92], // Burswood/Belmont approach
          [-31.927, 115.949], // Redcliffe
          [-31.938, 115.967], // Airport Central
          [-31.941, 116.0] // High Wycombe
        ]
      },
      {
        name: "Ellenbrook",
        points: [
          [-31.95, 115.86],
          [-31.93, 115.89],
          [-31.91, 115.915], // Bayswater connection
          [-31.89, 115.93],
          [-31.865, 115.897], // Noranda
          [-31.846, 115.89], // Malaga
          [-31.824, 115.95], // Whiteman
          [-31.79, 115.965],
          [-31.776, 115.97] // Ellenbrook
        ]
      }
    ];

    const busRoutes = [
      {
        name: "Kwinana Fwy BUS",
        points: [
          [-32.25, 115.84],
          [-32.2, 115.84],
          [-32.15, 115.84],
          [-32.1, 115.84],
          [-32.05, 115.85],
          [-32.0, 115.86],
          [-31.97, 115.86],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Mitchell Fwy BUS",
        points: [
          [-31.48, 115.7],
          [-31.6, 115.71],
          [-31.65, 115.71],
          [-31.7, 115.72],
          [-31.75, 115.74],
          [-31.8, 115.76],
          [-31.85, 115.78],
          [-31.9, 115.82],
          [-31.93, 115.84],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Albany Hwy",
        points: [
          [-32.15, 116.02],
          [-32.12, 116.0],
          [-32.08, 115.98],
          [-32.04, 115.95],
          [-32.0, 115.92],
          [-31.98, 115.9],
          [-31.96, 115.89],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Wanneroo Rd",
        points: [
          [-31.72, 115.78],
          [-31.78, 115.79],
          [-31.82, 115.81],
          [-31.86, 115.82],
          [-31.9, 115.84],
          [-31.93, 115.85],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Great Eastern Hwy",
        points: [
          [-31.94, 116.01],
          [-31.92, 115.99],
          [-31.9, 115.96],
          [-31.9, 115.93],
          [-31.92, 115.89],
          [-31.93, 115.87],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Canning Hwy",
        points: [
          [-32.05, 115.84],
          [-32.04, 115.85],
          [-32.02, 115.85],
          [-31.99, 115.85],
          [-31.97, 115.855],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Marmion/West Coast",
        points: [
          [-31.55, 115.74],
          [-31.6, 115.75],
          [-31.65, 115.76],
          [-31.7, 115.77],
          [-31.75, 115.78],
          [-31.8, 115.79],
          [-31.84, 115.8],
          [-31.88, 115.81],
          [-31.92, 115.83],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Scarborough Beach Rd",
        points: [
          [-31.894, 115.751],
          [-31.9, 115.77],
          [-31.905, 115.79],
          [-31.912, 115.81],
          [-31.918, 115.83],
          [-31.925, 115.85],
          [-31.932, 115.865],
          [-31.94, 115.88],
          [-31.95, 115.895],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Tonkin Hwy",
        points: [
          [-32.12, 116.0],
          [-32.08, 115.99],
          [-32.04, 115.98],
          [-32.0, 115.97],
          [-31.96, 115.96],
          [-31.92, 115.95],
          [-31.88, 115.94],
          [-31.84, 115.93],
          [-31.8, 115.91],
          [-31.76, 115.9]
        ]
      },
      {
        name: "Reid Hwy",
        points: [
          [-31.88, 115.93],
          [-31.88, 115.9],
          [-31.88, 115.86],
          [-31.88, 115.82],
          [-31.88, 115.78],
          [-31.88, 115.74],
          [-31.88, 115.7]
        ]
      },
      {
        name: "Roe Hwy",
        points: [
          [-32.12, 116.02],
          [-32.1, 116.0],
          [-32.08, 115.97],
          [-32.06, 115.94],
          [-32.04, 115.91],
          [-32.02, 115.88],
          [-31.99, 115.86]
        ]
      },
      {
        name: "Leach Hwy",
        points: [
          [-32.07, 115.83],
          [-32.05, 115.86],
          [-32.03, 115.88],
          [-32.01, 115.9],
          [-31.99, 115.91],
          [-31.97, 115.92],
          [-31.95, 115.93]
        ]
      },
      {
        name: "Stirling Hwy",
        points: [
          [-32.05, 115.77],
          [-32.02, 115.79],
          [-32.0, 115.8],
          [-31.99, 115.81],
          [-31.98, 115.82],
          [-31.97, 115.83],
          [-31.96, 115.84],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Scarborough Beach Rd",
        points: [
          [-31.894, 115.751],
          [-31.9, 115.77],
          [-31.905, 115.79],
          [-31.912, 115.81],
          [-31.918, 115.83],
          [-31.925, 115.85],
          [-31.932, 115.865],
          [-31.94, 115.88],
          [-31.95, 115.895],
          [-31.95, 115.86]
        ]
      }
    ];

    const railStations = [
      // Core CBD
      { name: "Perth Station", lat: -31.9516, lon: 115.8605 },
      { name: "Perth Underground", lat: -31.9524, lon: 115.8579 },
      { name: "Elizabeth Quay", lat: -31.9563, lon: 115.8543 },
      // Mandurah line
      { name: "Canning Bridge", lat: -32.0494, lon: 115.8517 },
      { name: "Bull Creek", lat: -32.064, lon: 115.852 },
      { name: "Murdoch", lat: -32.071, lon: 115.85 },
      { name: "Cockburn Central", lat: -32.1267, lon: 115.85 },
      { name: "Aubin Grove", lat: -32.175, lon: 115.843 },
      { name: "Rockingham", lat: -32.2745, lon: 115.73 },
      { name: "Mandurah", lat: -32.536, lon: 115.742 },
      // Joondalup / Yanchep
      { name: "Leederville", lat: -31.9361, lon: 115.8414 },
      { name: "Glendalough", lat: -31.917, lon: 115.84 },
      { name: "Stirling", lat: -31.8962, lon: 115.8097 },
      { name: "Warwick", lat: -31.8592, lon: 115.807 },
      { name: "Whitfords", lat: -31.811, lon: 115.767 },
      { name: "Joondalup", lat: -31.744, lon: 115.768 },
      { name: "Butler", lat: -31.639, lon: 115.71 },
      { name: "Yanchep", lat: -31.55, lon: 115.69 },
      // Fremantle
      { name: "Subiaco", lat: -31.95, lon: 115.817 },
      { name: "Claremont", lat: -31.986, lon: 115.781 },
      { name: "Cottesloe", lat: -32.009, lon: 115.756 },
      { name: "Fremantle", lat: -32.053, lon: 115.748 },
      // Midland
      { name: "Claisebrook", lat: -31.9503, lon: 115.8735 },
      { name: "Bayswater", lat: -31.9147, lon: 115.9136 },
      { name: "Guildford", lat: -31.9, lon: 115.967 },
      { name: "Midland", lat: -31.889, lon: 116.005 },
      // Armadale / Thornlie
      { name: "Burswood", lat: -31.961, lon: 115.894 },
      { name: "Oats Street", lat: -31.9805, lon: 115.8974 },
      { name: "Thornlie", lat: -32.0618, lon: 115.9521 },
      { name: "Gosnells", lat: -32.079, lon: 115.999 },
      { name: "Armadale", lat: -32.153, lon: 116.016 },
      // Airport
      { name: "Redcliffe", lat: -31.927, lon: 115.949 },
      { name: "Airport Central", lat: -31.938, lon: 115.967 },
      { name: "High Wycombe", lat: -31.9405, lon: 116.007 },
      // Ellenbrook
      { name: "Bayswater (Ellenbrook)", lat: -31.9147, lon: 115.9136 },
      { name: "Noranda", lat: -31.865, lon: 115.897 },
      { name: "Malaga", lat: -31.846, lon: 115.89 },
      { name: "Whiteman Park", lat: -31.824, lon: 115.95 },
      { name: "Ellenbrook", lat: -31.776, lon: 115.97 }
    ];

    const hillsZone = { latMin: -32.05, latMax: -31.75, lonMin: 116.0, lonMax: 116.2 };

    // Preloaded major-road bus corridors (approximated)
    const majorRoads = [
      {
        name: "Kwinana Fwy BUS",
        points: [
          [-32.25, 115.84],
          [-32.2, 115.84],
          [-32.15, 115.84],
          [-32.1, 115.84],
          [-32.05, 115.85],
          [-32.0, 115.86],
          [-31.97, 115.86],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Mitchell Fwy BUS",
        points: [
          [-31.48, 115.7],
          [-31.6, 115.71],
          [-31.65, 115.71],
          [-31.7, 115.72],
          [-31.75, 115.74],
          [-31.8, 115.76],
          [-31.85, 115.78],
          [-31.9, 115.82],
          [-31.93, 115.84],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Albany Hwy",
        points: [
          [-32.15, 116.02],
          [-32.12, 116.0],
          [-32.08, 115.98],
          [-32.04, 115.95],
          [-32.0, 115.92],
          [-31.98, 115.9],
          [-31.96, 115.89],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Wanneroo Rd",
        points: [
          [-31.72, 115.78],
          [-31.78, 115.79],
          [-31.82, 115.81],
          [-31.86, 115.82],
          [-31.9, 115.84],
          [-31.93, 115.85],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Great Eastern Hwy",
        points: [
          [-31.94, 116.01],
          [-31.92, 115.99],
          [-31.9, 115.96],
          [-31.9, 115.93],
          [-31.92, 115.89],
          [-31.93, 115.87],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Canning Hwy",
        points: [
          [-32.05, 115.84],
          [-32.04, 115.85],
          [-32.02, 115.85],
          [-31.99, 115.85],
          [-31.97, 115.855],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Marmion/West Coast",
        points: [
          [-31.55, 115.74],
          [-31.6, 115.75],
          [-31.65, 115.76],
          [-31.7, 115.77],
          [-31.75, 115.78],
          [-31.8, 115.79],
          [-31.84, 115.8],
          [-31.88, 115.81],
          [-31.92, 115.83],
          [-31.95, 115.86]
        ]
      }
    ];

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = (d) => (d * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function kmToDegLat(km) {
      return km / 111;
    }

    function kmToDegLon(km, lat) {
      return km / (111 * Math.cos((lat * Math.PI) / 180));
    }

    function densifyLine(points, stepKm = 1) {
      const dense = [];
      for (let i = 0; i < points.length - 1; i++) {
        const a = points[i];
        const b = points[i + 1];
        const dist = haversine(a[0], a[1], b[0], b[1]);
        const steps = Math.max(1, Math.round(dist / stepKm));
        for (let s = 0; s < steps; s++) {
          const t = s / steps;
          dense.push([a[0] + (b[0] - a[0]) * t, a[1] + (b[1] - a[1]) * t]);
        }
      }
      dense.push(points[points.length - 1]);
      return dense;
    }

    function buildFallbackStops() {
      const seen = new Set();
      const busStops = [];
      const railStops = [];
      function addStop(name, lat, lon, type) {
        const key = `${lat.toFixed(5)},${lon.toFixed(5)}`;
        if (seen.has(key)) return;
        seen.add(key);
        const stop = {
          stopid: `${type}-${busStops.length + railStops.length}`,
          stopname: name,
          lat,
          lon
        };
        if (type === "rail") railStops.push(stop);
        else busStops.push(stop);
      }
      railLines.forEach((line) => {
        const dense = densifyLine(line.points, 0.5);
        dense.forEach((p, idx) => addStop(`${line.name} rail ${idx}`, p[0], p[1], "rail"));
      });
      [...majorRoads, ...busRoutes].forEach((route) => {
        const dense = densifyLine(route.points, 0.3);
        dense.forEach((p, idx) => addStop(`${route.name} ${idx}`, p[0], p[1], "bus"));
      });
      return { busStops, railStops };
    }

    const FALLBACK_STOPS = buildFallbackStops();

    function stopNeighborPaths(stops, k = 3, maxDistKm = 1.5) {
      const paths = [];
      const seen = new Set();
      stops.forEach((s, idx) => {
        const candidates = [];
        stops.forEach((t, j) => {
          if (idx === j) return;
          const d = haversine(s.lat, s.lon, t.lat, t.lon);
          if (d <= maxDistKm) candidates.push({ t, d });
        });
        candidates
          .sort((a, b) => a.d - b.d)
          .slice(0, k)
          .forEach((c) => {
            const key =
              [s.lat, s.lon, c.t.lat, c.t.lon]
                .map((v) => v.toFixed(5))
                .sort()
                .join("|");
            if (seen.has(key)) return;
            seen.add(key);
            paths.push([
              [s.lat, s.lon],
              [c.t.lat, c.t.lon]
            ]);
          });
      });
      return paths;
    }

    function pointSegmentDistance(p, a, b) {
      const toRad = (d) => (d * Math.PI) / 180;
      const latScale = 111;
      const x1 = (a[1] - p[1]) * Math.cos(toRad((a[0] + p[0]) / 2)) * latScale;
      const y1 = (a[0] - p[0]) * latScale;
      const x2 = (b[1] - p[1]) * Math.cos(toRad((b[0] + p[0]) / 2)) * latScale;
      const y2 = (b[0] - p[0]) * latScale;
      const dot = x1 * x2 + y1 * y2;
      const lenSq = x2 * x2 + y2 * y2;
      const t = Math.max(0, Math.min(1, lenSq === 0 ? 0 : dot / lenSq));
      const projX = t * x2;
      const projY = t * y2;
      const dx = projX - x1;
      const dy = projY - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function corridorFactor(lat, lon) {
      let factor = 1;
      corridors.forEach((line) => {
        for (let i = 0; i < line.length - 1; i++) {
          const d = pointSegmentDistance([lat, lon], line[i], line[i + 1]);
          if (d < 1.5) {
            factor = Math.min(factor, 0.78 + d * 0.05);
          }
        }
      });
      if (
        lat >= hillsZone.latMin &&
        lat <= hillsZone.latMax &&
        lon >= hillsZone.lonMin &&
        lon <= hillsZone.lonMax
      ) {
        factor *= 1.12;
      }
      return factor;
    }

    function hexToRgb(hex) {
      const n = hex.replace("#", "");
      const v = n.length === 3 ? n.split("").map((c) => c + c).join("") : n;
      return {
        r: parseInt(v.slice(0, 2), 16),
        g: parseInt(v.slice(2, 4), 16),
        b: parseInt(v.slice(4, 6), 16)
      };
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    const TIME_COLORS = [
      { t: 0, c: "#22c55e" },
      { t: 15, c: "#84cc16" },
      { t: 30, c: "#facc15" },
      { t: 45, c: "#f97316" },
      { t: 60, c: "#ef4444" },
      { t: 90, c: "#be123c" },
      { t: 120, c: "#7e22ce" }
    ];

    function colourForMinutes(mins) {
      const clamped = Math.max(0, Math.min(120, mins));
      for (let i = 0; i < TIME_COLORS.length - 1; i++) {
        const a = TIME_COLORS[i];
        const b = TIME_COLORS[i + 1];
        if (clamped >= a.t && clamped <= b.t) {
          const t = (clamped - a.t) / (b.t - a.t || 1);
          const ca = hexToRgb(a.c);
          const cb = hexToRgb(b.c);
          const r = Math.round(lerp(ca.r, cb.r, t));
          const g = Math.round(lerp(ca.g, cb.g, t));
          const bcol = Math.round(lerp(ca.b, cb.b, t));
          return `rgb(${r}, ${g}, ${bcol})`;
        }
      }
      return TIME_COLORS[TIME_COLORS.length - 1].c;
    }

    function computeCommute(stop, baseWait, netSpeed) {
      if (!isValidStop(stop)) return Infinity;
      // estimate walk to stop (roughly 10 min per km)
      const walkKm = haversine(stop.lat, stop.lon, target.lat, target.lon) * 0.1;
      const walkPenalty = walkKm * 10;
      const distanceKm = haversine(stop.lat, stop.lon, target.lat, target.lon);
      const corridor = corridorFactor(stop.lat, stop.lon);
      const effectiveSpeed = netSpeed * (1 / corridor);
      const rideMins = (distanceKm / Math.max(effectiveSpeed, 1)) * 60;
      return baseWait + rideMins + walkPenalty;
    }

    function computeWait() {
      const base = Number(baseWait.value);
      const headway = Number(document.getElementById("headway").value || HEADWAY_MIN);
      const randomize = document.getElementById("randomWait").value === "true";
      if (!randomize) return base + headway / 2;
      return base + Math.random() * headway;
    }

    function applyScenario(preset) {
      const s = SCENARIOS[preset];
      if (!s) return;
      baseWait.value = s.baseWait;
      document.getElementById("headway").value = String(s.headway);
      document.getElementById("busSpeed").value = s.bus;
      document.getElementById("railSpeed").value = s.rail;
      document.getElementById("carSpeed").value = s.car;
      document.getElementById("randomWait").value = s.random ? "true" : "false";
      BUS_SPEED = s.bus;
      RAIL_SPEED = s.rail;
      CAR_SPEED = s.car;
      HEADWAY_MIN = s.headway;
      MODE_PREF = document.getElementById("modePref").value || MODE_PREF;
      renderStops(window.__stops || [], Number(baseWait.value), Number(netSpeed.value));
    }

    async function loadRoads() {
      try {
        const res = await fetch("data/roads-major.geojson");
        if (!res.ok) throw new Error("roads fetch failed");
        const geo = await res.json();
        roadsLayer.clearLayers();
        L.geoJSON(geo, {
          style: () => ({ color: "#94a3b8", weight: 1, opacity: 0.5 })
        }).addTo(roadsLayer);
        if (document.getElementById("toggleRoads").checked) {
          roadsLayer.addTo(map);
        }
      } catch (err) {
        console.warn("Roads load failed", err);
        lastError = err.message || "roads load failed";
      }
    }

    async function loadPropertyData() {
      try {
        const res = await fetch("data/property-prices.json");
        if (!res.ok) throw new Error("property data fetch failed");
        const data = await res.json();
        PROPERTY_DATA = Array.isArray(data) ? data : [];
      } catch (err) {
        console.warn("Property data load failed", err);
        lastError = err.message || "property load failed";
      }
    }

    function nearestProperty(lat, lon) {
      if (!PROPERTY_DATA || !PROPERTY_DATA.length) return null;
      let best = null;
      let bestD = Infinity;
      PROPERTY_DATA.forEach((p) => {
        const d = haversine(lat, lon, p.lat, p.lon);
        if (d < bestD) {
          bestD = d;
          best = p;
        }
      });
      return best ? { property: best, distKm: bestD } : null;
    }

    function renderRailLines(show) {
      railLayer.clearLayers();
      stationLayer.clearLayers();
      if (!show) return;
      railLines.forEach((line) => {
        const poly = L.polyline(line.points, {
          color: "var(--rail)",
          weight: 4,
          opacity: 0.8,
          dashArray: "4 6"
        }).addTo(railLayer);
        const midpoint = line.points[Math.floor(line.points.length / 2)];
        L.marker(midpoint, {
          interactive: false,
          icon: L.divIcon({
            className: "rail-label",
            html: line.name,
            iconSize: null
          })
        }).addTo(railLayer);
      });
      railStations.forEach((st) => {
        L.circleMarker([st.lat, st.lon], {
          radius: 5,
          color: "#0b1220",
          weight: 1,
          fillColor: "#ffffff",
          fillOpacity: 0.9
        })
          .bindTooltip(st.name, { permanent: false, direction: "top", offset: [0, -4] })
          .addTo(stationLayer);
      });
    }

    let metaState = { stops: 0, baseWait: Number(baseWait.value), speed: Number(netSpeed.value), data: "unknown" };
    let lastError = "";
    function isValidStop(s) {
      return s && Number.isFinite(Number(s.lat)) && Number.isFinite(Number(s.lon));
    }
    function sanitizeStops(list) {
      return (list || []).filter((s) => isValidStop(s));
    }
    const SCENARIOS = {
      peak: { baseWait: 6, headway: 6, bus: 50, rail: 70, car: 60, random: true },
      interpeak: { baseWait: 8, headway: 10, bus: 40, rail: 65, car: 70, random: true },
      night: { baseWait: 12, headway: 15, bus: 35, rail: 55, car: 80, random: false }
    };
    const panel = document.querySelector(".panel");
    function setBusy(msg, active = true) {
      const el = document.getElementById("busyBanner");
      if (!el) return;
      if (active) {
        el.textContent = msg || "Working…";
        el.classList.remove("hidden");
      } else {
        el.classList.add("hidden");
      }
    }

    function updateDebugMeta(overrides = {}) {
      metaState = { ...metaState, ...overrides };
      const busNodes = busGraph && busGraph.nodes ? busGraph.nodes.size : 0;
      const busRoutes = busGraph && busGraph.routes ? busGraph.routes.length : 0;
      const railNodes = railGraph && railGraph.nodes ? railGraph.nodes.size : 0;
      const meta = document.getElementById("debug-meta");
      meta.textContent = `Stops: ${metaState.stops} · Base wait: ${metaState.baseWait} min · Speed: ${metaState.speed} km/h · Data: ${metaState.data} · Graphs: bus ${busNodes} nodes/${busRoutes} routes, rail ${railNodes} nodes · Errors: ${ERROR_COUNT}${lastError ? ` (last: ${lastError})` : ""}`;
    }

    function renderStops(stops, baseWait, netSpeed) {
      stopsLayer.clearLayers();
      if (!document.getElementById("toggleStops").checked) {
        document.getElementById("status").textContent = "Stops hidden";
        updateDebugMeta({ stops: stops.length, baseWait, speed: netSpeed, data: DATA_SOURCE });
        return;
      }
      const majorPattern = /(station|busport|interchange|terminus|bus station)/i;
      const total = stops.length;
      const step = total > 4000 ? Math.ceil(total / 4000) : 1;
      stops.forEach((stop, idx) => {
        if (step > 1 && idx % step !== 0 && !majorPattern.test(stop.stopname || "")) return;
        const commute = computeCommute(stop, baseWait, netSpeed);
        const color = colourForMinutes(commute);
        const isMajor = majorPattern.test(stop.stopname || "");
        L.circleMarker([stop.lat, stop.lon], {
          radius: isMajor ? 8 : 5.5,
          color: isMajor ? "#d9f99d" : "#0d1b2a",
          weight: 1,
          fillColor: color,
          fillOpacity: 0.9
        })
          .bindPopup(
            `<strong>${stop.stopname || "Stop"}</strong><br>ID: ${stop.stopid}<br>${commute.toFixed(1)} min`
          )
          .addTo(stopsLayer);
      });
      const rendered = step > 1 ? Math.ceil(total / step) : total;
      document.getElementById("status").textContent = `Rendered ${rendered}/${total} stops`;
      updateDebugMeta({ stops: total, baseWait, speed: netSpeed, data: DATA_SOURCE });
    }

    function pauseHeavyLayers() {
      if (document.getElementById("toggleStops").checked && stopsLayer) {
        stopsLayer.remove();
        stopsHiddenForZoom = true;
      }
      if (heatVisLayer && heatVisLayer._map) {
        heatVisLayer.setOptions({ opacity: 0 });
        heatHiddenForZoom = true;
      }
      if (document.getElementById("toggleRoads").checked && roadsLayer && roadsLayer._map) {
        roadsLayer.remove();
        roadsHiddenForZoom = true;
      }
    }

    function resumeHeavyLayers() {
      if (stopsHiddenForZoom) {
        stopsLayer.addTo(map);
        stopsHiddenForZoom = false;
      }
      if (heatHiddenForZoom) {
        heatVisLayer.setOptions({ opacity: 0.9 });
        heatHiddenForZoom = false;
      }
      if (roadsHiddenForZoom) {
        roadsLayer.addTo(map);
        roadsHiddenForZoom = false;
      }
    }

    function readStopCache() {
      const cached = localStorage.getItem(STOP_CACHE_KEY);
      if (!cached) return null;
      try {
        const parsed = JSON.parse(cached);
        const ageHours = (Date.now() - parsed.ts) / 36e5;
        if (ageHours > STOP_CACHE_MAX_AGE_HRS) return null;
        return sanitizeStops(parsed.stops);
      } catch {
        return null;
      }
    }

    function writeStopCache(stops) {
      localStorage.setItem(STOP_CACHE_KEY, JSON.stringify({ ts: Date.now(), stops }));
    }

    function routeTileKey(tile) {
      return `${tile.minLat.toFixed(2)}_${tile.minLon.toFixed(2)}_${tile.maxLat.toFixed(2)}_${tile.maxLon.toFixed(2)}`;
    }

    function routeTilesForBbox(bbox) {
      const [minLat, minLon, maxLat, maxLon] = bbox;
      const size = 0.35;
      const tiles = [];
      for (let lat = minLat; lat < maxLat; lat += size) {
        for (let lon = minLon; lon < maxLon; lon += size) {
          tiles.push({
            minLat: lat,
            minLon: lon,
            maxLat: Math.min(maxLat, lat + size),
            maxLon: Math.min(maxLon, lon + size)
          });
        }
      }
      return tiles;
    }

    function readRouteCache() {
      const cached = localStorage.getItem(ROUTE_CACHE_KEY);
      if (!cached) return { tiles: {} };
      try {
        const parsed = JSON.parse(cached);
        return parsed && parsed.tiles ? parsed : { tiles: {} };
      } catch {
        return { tiles: {} };
      }
    }

    function writeRouteCache(cache) {
      localStorage.setItem(ROUTE_CACHE_KEY, JSON.stringify(cache));
    }

    async function fetchRoutes(bbox) {
      const status = document.getElementById("status");
      const cache = readRouteCache();
      const tiles = routeTilesForBbox(bbox);
      const now = Date.now();
      const expired = (ts) => (now - ts) / 36e5 > ROUTE_CACHE_MAX_AGE_HRS;
      const toFetch = tiles.filter((t) => {
        const k = routeTileKey(t);
        const entry = cache.tiles[k];
        return !entry || expired(entry.ts);
      });

      const mergedRoutes = [];
      tiles.forEach((t) => {
        const k = routeTileKey(t);
        if (cache.tiles[k] && cache.tiles[k].routes) {
          mergedRoutes.push(...cache.tiles[k].routes);
        }
      });

      for (const tile of toFetch) {
        status.textContent = "Fetching routes…";
        const url =
          "https://services.slip.wa.gov.au/public/rest/services/SLIP_Public_Services/Transport/MapServer/15/query" +
          "?where=1%3D1" +
          "&outFields=route_name,route_number" +
          `&geometry=${tile.minLon},${tile.minLat},${tile.maxLon},${tile.maxLat}` +
          "&geometryType=esriGeometryEnvelope" +
          "&inSR=4326&spatialRel=esriSpatialRelIntersects" +
          "&outSR=4326&f=json";
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`routes ${res.status}`);
          const data = await res.json();
          const routes = (data.features || [])
            .map((f) => ({
              name: f.attributes.route_name || f.attributes.route_number || "route",
              paths: f.geometry.paths || []
            }))
            .filter((r) => r.paths.length > 0);
          cache.tiles[routeTileKey(tile)] = { routes, ts: now };
          mergedRoutes.push(...routes);
        } catch (err) {
          console.error(err);
        }
      }

      writeRouteCache(cache);
      status.textContent = `Routes ready (${mergedRoutes.length})`;
      return mergedRoutes;
    }

    async function fetchStops() {
      const status = document.getElementById("status");
      const cached = readStopCache();
      if (cached && cached.length > 0) {
        status.textContent = `Loaded ${cached.length} stops from cache`;
        return cached;
      }
      status.textContent = "Fetching stops…";
      const url =
        "https://services.slip.wa.gov.au/public/rest/services/SLIP_Public_Services/Transport_Public_PT_Stops/FeatureServer/14/query" +
        "?where=1%3D1" +
        "&outFields=stopid,stopname" +
        "&geometry=-32.6,115.5,-31.4,116.2" +
        "&geometryType=esriGeometryEnvelope" +
        "&inSR=4326&spatialRel=esriSpatialRelIntersects" +
        "&outSR=4326&f=json";
      try {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`Failed to fetch stops: ${res.status}`);
        }
        const data = await res.json();
        const stops = sanitizeStops(
          (data.features || [])
          .map((f) => ({
            stopid: f.attributes.stopid,
            stopname: f.attributes.stopname,
            lat: f.geometry.y,
            lon: f.geometry.x
          }))
        );
        if (!stops.length) throw new Error("No stops fetched");
        DATA_SOURCE = "live";
        status.textContent = `Loaded ${stops.length} stops`;
        writeStopCache(stops);
        return stops;
      } catch (err) {
        console.warn("Stop fetch failed, using fallback sample stops", err);
        lastError = err.message || "stop fetch failed";
        const local = await loadLocalFallbackStops();
        const localClean = sanitizeStops(local);
        if (localClean && localClean.length) {
          DATA_SOURCE = "local-fallback";
          status.textContent = `Using local fallback stops (${localClean.length})`;
          writeStopCache(localClean);
          return localClean;
        }
        const fallbacks = sanitizeStops([...SAMPLE_STOPS, ...FALLBACK_STOPS.busStops, ...FALLBACK_STOPS.railStops]);
        DATA_SOURCE = "generated-fallback";
        status.textContent = `Using generated fallback stops (${fallbacks.length})`;
        writeStopCache(fallbacks);
        return fallbacks;
      }
    }

    function sampleCorridorDebug(lat, lon) {
      const factor = corridorFactor(lat, lon);
      const mins = computeCommute({ lat, lon }, Number(baseWait.value), Number(netSpeed.value));
      return { factor, mins };
    }

    async function init() {
      try {
        setBusy("Loading data…", true);
        const stops = await fetchStops();
        window.__stops = stops;
        renderStops(stops, Number(baseWait.value), Number(netSpeed.value));
        renderRailLines(toggleRail.checked);
        loadRoads();
        loadPropertyData();
        // prefetch metro routes
        try {
          const routes = await fetchRoutes([-32.6, 115.5, -31.4, 116.2]);
          routeGraph = buildRouteGraph(routes);
          const stopPaths = stopNeighborPaths(window.__stops || []);
          const combined = routes
            .concat(majorRoads.map((r) => ({ name: r.name, paths: [r.points] })))
            .concat([{ name: "stop-graph", paths: stopPaths }]);
          busGraph = buildRouteGraph(combined);
          railGraph = buildRouteGraph(railLines.map((r) => ({ name: r.name, paths: [r.points] })));
        } catch (err) {
          console.error("Route fetch failed, using corridors only", err);
          routeGraph = { nodes: new Map(), routes: [] };
          const stopPaths = stopNeighborPaths(window.__stops || []);
          busGraph = buildRouteGraph(
            majorRoads.map((r) => ({ name: r.name, paths: [r.points] })).concat([{ name: "stop-graph", paths: stopPaths }])
          );
          railGraph = buildRouteGraph(railLines.map((r) => ({ name: r.name, paths: [r.points] })));
        }
        updateDebugMeta();
        const dbg = sampleCorridorDebug(-31.96, 115.86);
        document.getElementById("debug-corridor").textContent = `CBD sample corridor factor: ${dbg.factor.toFixed(2)} · est ${dbg.mins.toFixed(1)} min`;
        document.getElementById("debug").firstElementChild.textContent = "Debug — ok";
        DATA_READY = true;
        document.getElementById("status").textContent = "Ready (click map to simulate)";
        setBusy("", false);
        if (window.innerWidth < 720 && panel) panel.classList.add("hidden");
      } catch (e) {
        document.getElementById("status").textContent = e.message;
        document.getElementById("debug").firstElementChild.textContent = `Debug — ${e.message}`;
        console.error(e);
        setBusy(e.message, false);
      }
    }

    document.getElementById("recompute").addEventListener("click", () => {
      if (!window.__stops) return;
      renderStops(window.__stops, Number(baseWait.value), Number(netSpeed.value));
    });
    document.getElementById("toggleRail").addEventListener("change", (e) => {
      renderRailLines(e.target.checked);
    });
    document.getElementById("toggleRoads").addEventListener("change", (e) => {
      if (e.target.checked) {
        roadsLayer.addTo(map);
      } else {
        roadsLayer.remove();
      }
    });
    document.getElementById("toggleStops").addEventListener("change", () => {
      if (window.__stops) renderStops(window.__stops, Number(baseWait.value), Number(netSpeed.value));
    });

    function loadSnapshots() {
      const raw = localStorage.getItem(SNAPSHOT_CACHE_KEY);
      if (!raw) return [];
      try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function saveSnapshots(list) {
      localStorage.setItem(SNAPSHOT_CACHE_KEY, JSON.stringify(list));
    }

    function renderSnapshots() {
      const container = document.getElementById("snapshots");
      container.innerHTML = "";
      const snaps = loadSnapshots();
      snaps.forEach((snap) => {
        const card = document.createElement("div");
        card.className = "snapshot-card";
        const img = document.createElement("img");
        img.src = snap.dataUrl;
        img.alt = "Map snapshot";
        card.appendChild(img);
        const meta = document.createElement("div");
        meta.className = "snapshot-meta";
        meta.textContent = `${new Date(snap.ts).toLocaleString()} · z${snap.zoom}`;
        card.appendChild(meta);
        const btn = document.createElement("button");
        btn.textContent = "Load view";
        btn.onclick = () => {
          map.setView([snap.center.lat, snap.center.lon], snap.zoom);
          if (window.__stops) {
            renderStops(window.__stops, snap.baseWait, snap.netSpeed);
          }
        };
        card.appendChild(btn);
        const del = document.createElement("button");
        del.textContent = "Delete";
        del.onclick = () => {
          const next = loadSnapshots().filter((s) => s.id !== snap.id);
          saveSnapshots(next);
          renderSnapshots();
        };
        card.appendChild(del);
        container.appendChild(card);
      });
    }

    document.getElementById("saveSnapshot").addEventListener("click", () => {
      if (!window.leafletImage) {
        alert("Snapshot helper not loaded yet.");
        return;
      }
      leafletImage(map, (err, canvas) => {
        if (err) {
          alert("Snapshot failed");
          return;
        }
        const dataUrl = canvas.toDataURL("image/png");
        const snaps = loadSnapshots();
        const snap = {
          id: crypto.randomUUID(),
          ts: Date.now(),
          dataUrl,
          center: { lat: map.getCenter().lat, lon: map.getCenter().lng },
          zoom: map.getZoom(),
          baseWait: Number(baseWait.value),
          netSpeed: Number(netSpeed.value)
        };
        snaps.unshift(snap);
        const trimmed = snaps.slice(0, 6);
        saveSnapshots(trimmed);
        renderSnapshots();
      });
    });

    function loadHeat() {
      const raw = localStorage.getItem("simHeatV1");
      if (!raw) return [];
      try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function saveHeat(list) {
      localStorage.setItem("simHeatV1", JSON.stringify(list));
    }

    function renderHeat() {
      heatLineLayer.clearLayers();
      const heat = loadHeat();
      const heatPoints = [];
      heat.forEach((h) => {
        L.polyline(h.path, {
          color: h.color,
          weight: 2,
          opacity: 0.18
        }).addTo(heatLineLayer);
        const sampled = samplePath(h.path);
        sampled.forEach((p) => heatPoints.push([p[0], p[1], h.weight]));
      });
      heatVisLayer.setLatLngs(heatPoints);
    }

    function samplePath(path) {
      const pts = [];
      for (let i = 0; i < path.length - 1; i++) {
        const a = path[i];
        const b = path[i + 1];
        const seg = haversine(a[0], a[1], b[0], b[1]);
        const steps = Math.max(1, Math.floor(seg / 0.35)); // sample roughly every 350m
        for (let s = 0; s <= steps; s++) {
          const t = s / steps;
          pts.push([a[0] + (b[0] - a[0]) * t, a[1] + (b[1] - a[1]) * t]);
        }
      }
      return pts;
    }

    function addHeatPath(path, minutes) {
      const heat = loadHeat();
      const color = colourForMinutes(minutes);
      const weight = Math.min(1, Math.max(0.2, minutes / 90));
      heat.unshift({ path, color, ts: Date.now(), weight });
      const trimmed = heat.slice(0, 200);
      saveHeat(trimmed);
      renderHeat();
    }

    function randomTravelPlan(lat, lon) {
      const travel =
        busToRailRoute({ lat, lng: lon }) || graphRouteToCBD({ lat, lng: lon }) || buildTravelPath({ lat, lng: lon });
      if (!travel || !travel.path || travel.path.length < 3) return null;
      return travel;
    }

    function randomStopWithin(distMinKm = 0, distMaxKm = 120) {
      if (!window.__stops || !window.__stops.length) return null;
      const candidates = window.__stops.filter((s) => {
        const d = haversine(s.lat, s.lon, target.lat, target.lon);
        return d >= distMinKm && d <= distMaxKm;
      });
      if (!candidates.length) return window.__stops[Math.floor(rand() * window.__stops.length)];
      return candidates[Math.floor(rand() * candidates.length)];
    }

    function simulateRandom(count = 20) {
      if (!DATA_READY) {
        document.getElementById("status").textContent = "Still loading data…";
        return;
      }
      setBusy("Running random sim…", true);
      const keep = document.getElementById("keepVisuals").checked;
      if (!keep) {
        // clear previous sim layers and heat for fresh batch
        simRootLayer.clearLayers();
        simTimers.forEach((t) => clearInterval(t));
        simTimers = [];
        heatLineLayer.clearLayers();
        heatVisLayer.setLatLngs([]);
        saveHeat([]);
      }
      const bounds = { minLat: -32.6, maxLat: -31.4, minLon: 115.5, maxLon: 116.2 };
      for (let i = 0; i < count; i++) {
        const stop = randomStopWithin(0, 120);
        if (!stop) continue;
        const jitterLat = stop.lat + kmToDegLat((rand() - 0.5) * 0.8);
        const jitterLon = stop.lon + kmToDegLon((rand() - 0.5) * 0.8, stop.lat);
        const travel = randomTravelPlan(jitterLat, jitterLon);
        if (!travel || !travel.near || !isValidStop(travel.near.stop)) continue;
        if (i < 5) {
          animateTravel({ lat: jitterLat, lng: jitterLon });
        } else {
          const base = Number(baseWait.value);
          const speed = Number(netSpeed.value);
          const commute = computeCommute(travel.near.stop, base, speed);
          addHeatPath(travel.path, commute);
        }
      }
      setBusy("", false);
    }

    function rainSim(drops = 80) {
      if (!DATA_READY) return;
      const keep = document.getElementById("keepVisuals").checked;
      if (!keep) simRootLayer.clearLayers();
      for (let i = 0; i < drops; i++) {
        const stop = randomStopWithin(0, 80);
        if (!stop) continue;
        const jitterLat = stop.lat + kmToDegLat((rand() - 0.5) * 0.6);
        const jitterLon = stop.lon + kmToDegLon((rand() - 0.5) * 0.6, stop.lat);
        const travel = randomTravelPlan(jitterLat, jitterLon);
        if (!travel || !travel.near || !isValidStop(travel.near.stop)) continue;
        const modeColor = MODE_COLORS[travel.mode || "auto"] || MODE_COLORS.fallback;
        L.polyline(travel.path, { color: modeColor, weight: 1.5, opacity: 0.4 }).addTo(simRootLayer);
      }
      document.getElementById("status").textContent = `Rain sim: ${drops} drops`;
    }

    function simulateRadial(rings = [5, 12, 25], perRing = 6) {
      if (!DATA_READY) return;
      setBusy("Running radial sim…", true);
      const keep = document.getElementById("keepVisuals").checked;
      if (!keep) {
        simRootLayer.clearLayers();
      }
      const seeds = [];
      rings.forEach((km) => {
        for (let i = 0; i < perRing; i++) {
          const bearing = (i / perRing) * 2 * Math.PI;
          const lat = target.lat + kmToDegLat(km) * Math.cos(bearing);
          const lon = target.lon + kmToDegLon(km, target.lat) * Math.sin(bearing);
          seeds.push({ lat, lon });
        }
      });
      seeds.forEach((s, idx) => {
        const travel = randomTravelPlan(s.lat, s.lon);
        if (!travel || !travel.near || !isValidStop(travel.near.stop)) return;
        if (idx < 6) {
          animateTravel({ lat: s.lat, lng: s.lon });
        } else {
          const base = Number(baseWait.value);
          const speed = Number(netSpeed.value);
          const commute = computeCommute(travel.near.stop, base, speed);
          addHeatPath(travel.path, commute);
        }
      });
      document.getElementById("status").textContent = `Radial sims: ${seeds.length} seeds`;
      setBusy("", false);
    }

    document.getElementById("simulateRandom").addEventListener("click", () => {
      simulateRandom(25);
    });

    document.getElementById("scarboroughDemo").addEventListener("click", () => {
      const scarb = { lat: -31.894, lng: 115.751 };
      animateTravel(scarb);
      map.setView([scarb.lat, scarb.lng], 12);
    });
    document.getElementById("radialSim").addEventListener("click", () => {
      simulateRadial([6, 12, 24], 8);
    });
    document.getElementById("runPreset").addEventListener("click", () => {
      const key = document.getElementById("presetSelect").value;
      const preset = PRESETS[key];
      if (!preset) return;
      animateTravel({ lat: preset.lat, lng: preset.lon });
      map.setView([preset.lat, preset.lon], 12);
    });
    document.getElementById("rushSim").addEventListener("click", () => {
      if (!window.__stops || !window.__stops.length) return;
      if (!document.getElementById("keepVisuals").checked) simRootLayer.clearLayers();
      const batch = window.__stops.filter((_, i) => i % 15 === 0).slice(0, 300);
      batch.forEach((s, idx) => {
        if (idx < 8) {
          animateTravel({ lat: s.lat, lng: s.lon });
          return;
        }
        const travel = buildTravelPath({ lat: s.lat, lng: s.lon });
        if (!travel || !travel.path || travel.path.length < 3) return;
        const modeColor = MODE_COLORS[travel.mode || "auto"] || MODE_COLORS.fallback;
        L.polyline(travel.path, { color: modeColor, weight: 2, opacity: 0.6 }).addTo(simRootLayer);
      });
      document.getElementById("status").textContent = `Rush sim: ${batch.length} starts`;
    });
    document.getElementById("rainSim").addEventListener("click", () => {
      rainSim(100);
    });
    document.getElementById("scenarioPreset").addEventListener("change", (e) => {
      const v = e.target.value;
      if (v === "custom") return;
      applyScenario(v);
    });

    document.getElementById("modePref").addEventListener("change", (e) => {
      MODE_PREF = e.target.value;
    });
    document.getElementById("allowTransfer").addEventListener("change", (e) => {
      ALLOW_TRANSFER = e.target.value === "true";
    });
    document.getElementById("busSpeed").addEventListener("change", (e) => {
      BUS_SPEED = Number(e.target.value);
    });
    document.getElementById("railSpeed").addEventListener("change", (e) => {
      RAIL_SPEED = Number(e.target.value);
    });
    document.getElementById("carSpeed").addEventListener("change", (e) => {
      CAR_SPEED = Number(e.target.value);
    });
    document.getElementById("headway").addEventListener("change", (e) => {
      HEADWAY_MIN = Number(e.target.value);
    });
    document.getElementById("randomWait").addEventListener("change", (e) => {
      RANDOM_WAIT = e.target.value === "true";
    });
    document.getElementById("clearCaches").addEventListener("click", () => {
      localStorage.removeItem(STOP_CACHE_KEY);
      localStorage.removeItem(ROUTE_CACHE_KEY);
      localStorage.removeItem("simHeatV1");
      routeGraph = null;
      heatLineLayer.clearLayers();
      heatVisLayer.setLatLngs([]);
      simRootLayer.clearLayers();
      simTimers.forEach((t) => clearInterval(t));
      simTimers = [];
      document.getElementById("status").textContent = "Caches/visuals cleared";
    });
    document.getElementById("demoRun").addEventListener("click", () => {
      animateTravel({ lat: -31.98, lng: 115.85 });
    });
    document.getElementById("clearVisuals").addEventListener("click", () => {
      heatLineLayer.clearLayers();
      heatVisLayer.setLatLngs([]);
      simRootLayer.clearLayers();
      simTimers.forEach((t) => clearInterval(t));
      simTimers = [];
      document.getElementById("status").textContent = "Visuals cleared";
    });

    renderSnapshots();
    renderHeat();
    init().then(() => {
      // seed a small batch if no heat is cached
      if (!loadHeat().length && window.__stops && window.__stops.length > 0) {
        simulateRandom(15);
      }
    });

    function nearestStop(lat, lon) {
      if (!window.__stops) return null;
      let best = null;
      let bestDist = Infinity;
      window.__stops.forEach((s) => {
        const d = haversine(lat, lon, s.lat, s.lon);
        if (d < bestDist) {
          bestDist = d;
          best = s;
        }
      });
      return { stop: best, distKm: bestDist };
    }

    function nearestPointIndex(points, lat, lon) {
      let idx = 0;
      let best = Infinity;
      points.forEach((p, i) => {
        const d = haversine(lat, lon, p[0], p[1]);
        if (d < best) {
          best = d;
          idx = i;
        }
      });
      return { idx, distKm: best };
    }

    function bestLineForStop(stop) {
      let winner = null;
      railLines.forEach((line) => {
        const nearStop = nearestPointIndex(line.points, stop.lat, stop.lon);
        if (!winner || nearStop.distKm < winner.stopDist) {
          const nearCbd = nearestPointIndex(line.points, target.lat, target.lon);
          winner = {
            line,
            stopIdx: nearStop.idx,
            stopDist: nearStop.distKm,
            cbdIdx: nearCbd.idx,
            cbdDist: nearCbd.distKm
          };
        }
      });
      return winner;
    }

    function bestBusRouteForStop(stop) {
      let winner = null;
      const sources = [];
      if (busGraph && busGraph.routes) {
        busGraph.routes.forEach((r) => sources.push({ dynamic: true, route: r }));
      }
      busRoutes.forEach((r) => sources.push({ dynamic: false, route: { name: r.name, paths: [r.points] } }));
      majorRoads.forEach((r) => sources.push({ dynamic: false, route: { name: r.name, paths: [r.points] } }));
      sources.forEach((src) => {
        src.route.paths.forEach((pts) => {
          const nearStop = nearestPointIndex(pts, stop.lat, stop.lon);
          const nearCbd = nearestPointIndex(pts, target.lat, target.lon);
          const span = Math.abs(nearStop.idx - nearCbd.idx);
          if (!winner || nearStop.distKm < winner.stopDist) {
            winner = {
              route: src.route,
              stopIdx: nearStop.idx,
              stopDist: nearStop.distKm,
              cbdIdx: nearCbd.idx,
              cbdDist: nearCbd.distKm,
              span,
              points: pts
            };
          }
        });
      });
      return winner;
    }

    function multimodalPath(startLatLng, modePref, allowTransfer) {
      const start = { lat: startLatLng.lat, lon: startLatLng.lng };
      const stopInfo = nearestStop(start.lat, start.lon);
      if (!stopInfo || !stopInfo.stop) return null;
      const near = stopInfo.stop;
      const localBusGraph = busGraph || routeGraph;
      const localRailGraph = railGraph || buildRouteGraph(railLines.map((r) => ({ paths: [r.points] })));

      function pathFromGraph(graph, src, dst, goalKey) {
        if (!graph || !graph.nodes || graph.nodes.size === 0) return [];
        const p = shortestPath(graph, src, dst, goalKey);
        return p || [];
      }

      const path = [];
      path.push([start.lat, start.lon]);
      path.push([near.lat, near.lon]);

      if (modePref === "rail") {
        if (!railTargetKey) railTargetKey = nearestNodeKey(localRailGraph.nodes, target.lat, target.lon);
        const railPath = pathFromGraph(localRailGraph, { lat: near.lat, lon: near.lon }, target, railTargetKey);
        path.push(...railPath);
        return { path, near, mode: "rail" };
      }

      if (modePref === "bus" && localBusGraph) {
        if (!busTargetKey) busTargetKey = nearestNodeKey(localBusGraph.nodes, target.lat, target.lon);
        const busPath = pathFromGraph(localBusGraph, { lat: near.lat, lon: near.lon }, target, busTargetKey);
        if (busPath.length) {
          path.push(...busPath);
          return { path, near, mode: "bus" };
        }
      }

      if (modePref === "mixed" && allowTransfer && localBusGraph) {
        if (!railTargetKey && localRailGraph && localRailGraph.nodes.size > 0) {
          railTargetKey = nearestNodeKey(localRailGraph.nodes, target.lat, target.lon);
        }
        // find best rail anchor
        let bestRail = null;
        railStations.forEach((st) => {
          const stBusKey = nearestNodeKey(localBusGraph.nodes, st.lat, st.lon);
          const stRailKey = localRailGraph ? nearestNodeKey(localRailGraph.nodes, st.lat, st.lon) : null;
          const busPart = pathFromGraph(
            localBusGraph,
            { lat: near.lat, lon: near.lon },
            { lat: st.lat, lon: st.lon },
            stBusKey
          );
          if (busPart && busPart.length && localRailGraph) {
            const railPart = pathFromGraph(
              localRailGraph,
              { lat: st.lat, lon: st.lon },
              target,
              railTargetKey || stRailKey
            );
            if (railPart && railPart.length) {
              const totalLen = pathLength(busPart) + pathLength(railPart);
              if (!bestRail || totalLen < bestRail.len) {
                bestRail = { busPart, railPart, len: totalLen, anchor: st };
              }
            }
          }
        });
        if (bestRail) {
          path.push(...bestRail.busPart);
          // ensure transfer node
          path.push([bestRail.anchor.lat, bestRail.anchor.lon]);
          path.push(...bestRail.railPart);
          return { path, near, mode: "mixed-transfer" };
        }
      }

      // fallback: nearest bus/rail corridor heuristic
      const alt = buildTravelPathLegacy(startLatLng);
      if (alt) return alt;
      return null;
    }

    function pathLength(path) {
      let d = 0;
      for (let i = 0; i < path.length - 1; i++) {
        d += haversine(path[i][0], path[i][1], path[i + 1][0], path[i + 1][1]);
      }
      return d;
    }

    let busTargetKey = null;
    let railTargetKey = null;

    function busToRailRoute(start) {
      if (!busGraph || !railGraph || !window.__stops) return null;
      const near = nearestStop(start.lat, start.lon);
      if (!near.stop) return null;
      if (!busTargetKey) busTargetKey = nearestNodeKey(busGraph.nodes, target.lat, target.lon);
      if (!railTargetKey) railTargetKey = nearestNodeKey(railGraph.nodes, target.lat, target.lon);
      const walkLeg = [
        [start.lat, start.lng],
        [near.stop.lat, near.stop.lon]
      ];
      let best = null;
      railStations.forEach((st) => {
        const stBusKey = nearestNodeKey(busGraph.nodes, st.lat, st.lon);
        const stRailKey = nearestNodeKey(railGraph.nodes, st.lat, st.lon);
        const busPart = shortestPath(
          busGraph,
          { lat: near.stop.lat, lon: near.stop.lon },
          { lat: st.lat, lon: st.lon },
          stBusKey
        );
        const railPart = shortestPath(railGraph, { lat: st.lat, lon: st.lon }, target, railTargetKey || stRailKey);
        if (busPart && busPart.length && railPart && railPart.length) {
          const len = pathLength(busPart) + pathLength(railPart);
          if (!best || len < best.len) {
            best = { busPart, railPart, station: st, len };
          }
        }
      });
      if (!best) return null;
      const path = walkLeg.concat(best.busPart, [[best.station.lat, best.station.lon]], best.railPart);
      return { path, near, mode: "bus-rail" };
    }

    function graphRouteToCBD(start) {
      if (!busGraph || !busGraph.nodes || busGraph.nodes.size === 0 || !window.__stops) return null;
      const near = nearestStop(start.lat, start.lon);
      if (!near.stop) return null;
      if (!busTargetKey) busTargetKey = nearestNodeKey(busGraph.nodes, target.lat, target.lon);
      const walkLeg = [
        [start.lat, start.lng],
        [near.stop.lat, near.stop.lon]
      ];
      const p = shortestPath(busGraph, { lat: near.stop.lat, lon: near.stop.lon }, target, busTargetKey);
      if (p && p.length > 1) {
        return {
          path: walkLeg.concat(p),
          near,
          mode: "bus-graph"
        };
      }
      return null;
    }

    function buildTravelPathLegacy(clickLatLng) {
      if (!window.__stops) return null;
      const near = nearestStop(clickLatLng.lat, clickLatLng.lng);
      if (!near.stop) return null;

      const path = [];
      path.push([clickLatLng.lat, clickLatLng.lng]);
      path.push([near.stop.lat, near.stop.lon]);

      const railChoice = bestLineForStop(near.stop);
      const busChoice = bestBusRouteForStop(near.stop);

      function buildCorridor(choice, points) {
        const linePoints = points;
        const stopIdx = choice.stopIdx;
        const cbdIdx = choice.cbdIdx;
        path.push(linePoints[stopIdx]);
        const slice =
          stopIdx <= cbdIdx ? linePoints.slice(stopIdx, cbdIdx + 1) : linePoints.slice(cbdIdx, stopIdx + 1).reverse();
        slice.forEach((p) => {
          const last = path[path.length - 1];
          if (!(last[0] === p[0] && last[1] === p[1])) path.push(p);
        });
      }

      const railSpan = railChoice ? Math.abs(railChoice.stopIdx - railChoice.cbdIdx) : Infinity;
      const busSpan = busChoice ? Math.abs(busChoice.stopIdx - busChoice.cbdIdx) : Infinity;

      if (busChoice && busSpan <= railSpan) {
        buildCorridor(busChoice, busChoice.points);
      } else if (railChoice) {
        buildCorridor(railChoice, railChoice.line.points);
      }

      path.push([target.lat, target.lon]);
      return { path, near, railChoice, busChoice };
    }

    function carRouteToCBD(start) {
      if (!busGraph || !busGraph.nodes || busGraph.nodes.size === 0 || !window.__stops) return null;
      const near = nearestStop(start.lat, start.lon);
      if (!near.stop) return null;
      const targetKey = nearestNodeKey(busGraph.nodes, target.lat, target.lon);
      const startKey = nearestNodeKey(busGraph.nodes, near.stop.lat, near.stop.lon);
      if (!startKey || !targetKey) return null;
      const p = shortestPath(busGraph, { lat: near.stop.lat, lon: near.stop.lon }, target, targetKey);
      if (p && p.length > 1) {
        return {
          path: [
            [start.lat, start.lng],
            [near.stop.lat, near.stop.lon],
            ...p
          ],
          near,
          mode: "car"
        };
      }
      return null;
    }

    function buildTravelPath(clickLatLng) {
      const pref = document.getElementById("modePref").value || MODE_PREF;
      const allow = document.getElementById("allowTransfer").value === "true";
      MODE_PREF = pref;
      ALLOW_TRANSFER = allow;
      if (!window.__stops || !window.__stops.length) {
        lastError = "Stops not loaded";
        updateDebugMeta();
        return null;
      }
      const attempts = [
        pref === "car" ? () => carRouteToCBD(clickLatLng) : null,
        pref !== "rail" && pref !== "car" ? () => busToRailRoute(clickLatLng) : null,
        pref !== "car" ? () => graphRouteToCBD(clickLatLng) : null,
        pref !== "car" ? () => multimodalPath(clickLatLng, pref, allow) : null,
        () => buildTravelPathLegacy(clickLatLng)
      ].filter(Boolean);
      for (const fn of attempts) {
        const travel = fn();
        if (travel && travel.path && travel.path.length > 2) return travel;
      }
      return null;
    }

    function animateTravel(clickLatLng) {
      if (!window.__stops) {
        document.getElementById("status").textContent = "Stops not loaded yet";
        return;
      }
      if (!DATA_READY) {
        document.getElementById("status").textContent = "Still loading data… (using fallbacks)";
      }

      const travel = buildTravelPath(clickLatLng);
      if (!travel || !travel.path || travel.path.length < 3 || !travel.near || !isValidStop(travel.near.stop)) {
        document.getElementById("status").textContent = "No path found for click (need bus/rail data)";
        return;
      }
      const { path, near } = travel;
      const mode = travel.mode || "auto";
      const nearestProp = nearestProperty(path[0][0], path[0][1]);
      // persist heat contribution for this click
      const base = mode === "car" ? 0 : computeWait();
      const speed = mode === "car" ? Number(document.getElementById("carSpeed").value || CAR_SPEED) : Number(netSpeed.value);
      const commute = computeCommute(near.stop, base, speed);
      addHeatPath(path, commute);

      const totalLen = pathLength(path);
      const debugPath = document.getElementById("debug-path");
      debugPath.textContent = `Path pts: ${path.length} · len ${totalLen.toFixed(1)} km · ETA ${commute.toFixed(
        1
      )}m · mode ${mode}${nearestProp ? ` · price $${nearestProp.property.priceK}k (${nearestProp.property.name})` : ""}`;
      console.log("Sim path", { mode, base, speed, commute, totalLen, points: path, nearStop: near.stop });

      const waitRatio = Math.min(0.6, base / Math.max(commute, 0.1));
      const totalSec = Math.max(4, Math.min(10, commute / 8)); // scale visual time

      const segLengths = [];
      let totalSegLen = 0;
      for (let i = 0; i < path.length - 1; i++) {
        const seg = haversine(path[i][0], path[i][1], path[i + 1][0], path[i + 1][1]);
        segLengths.push(seg);
        totalSegLen += seg;
      }

      const simLayer = L.layerGroup().addTo(simRootLayer);
      const modeColor = MODE_COLORS[mode] || MODE_COLORS.fallback;
      for (let i = 0; i < path.length - 1; i++) {
        const start = path[i];
        const end = path[i + 1];
        L.polyline([start, end], { color: modeColor, weight: 3, opacity: 0.8 }).addTo(simLayer);
      }

      const startMarker = L.circleMarker(path[0], { radius: 5, color: "#38bdf8", fillColor: "#38bdf8", fillOpacity: 0.8 }).addTo(simLayer);
      startMarker.bindTooltip("Clicked origin", { direction: "top", offset: [0, -4], permanent: false });
      const stopMarker = L.circleMarker(path[1], { radius: 7, color: "#f97316", fillColor: "#f97316", fillOpacity: 0.9 }).addTo(simLayer);
      stopMarker.bindTooltip(`Nearest stop: ${near.stop.stopname || near.stop.stopid}`, { direction: "top", offset: [0, -4], permanent: false });

      const mover = L.circleMarker(path[1], { radius: 6, color: "#f59e0b", fillColor: "#f59e0b", fillOpacity: 0.95 }).addTo(simLayer);
      const label = L.marker(path[1], {
        icon: L.divIcon({
          className: "rail-label",
          html: "",
          iconSize: null
        })
      }).addTo(simLayer);

      const startTs = performance.now();
      const timer = setInterval(() => {
        const elapsed = (performance.now() - startTs) / 1000;
        const progress = Math.min(1, elapsed / totalSec);
        const minutesUsed = progress * commute;
        const minutesLeft = Math.max(0, commute - minutesUsed);

        if (progress < waitRatio) {
          mover.setLatLng(path[1]);
          label.setLatLng(path[1]);
          label.setIcon(
            L.divIcon({
              className: "rail-label",
              html: `Waiting… ${minutesLeft.toFixed(1)}m`,
              iconSize: null
            })
          );
        } else {
          const moveProgress = (progress - waitRatio) / (1 - waitRatio);
          const moveDist = moveProgress * totalLen;
          let acc = 0;
          let segIndex = 0;
          while (segIndex < segLengths.length && acc + segLengths[segIndex] < moveDist) {
            acc += segLengths[segIndex];
            segIndex++;
          }
          if (segIndex >= segLengths.length) {
            mover.setLatLng(path[path.length - 1]);
            label.setLatLng(path[path.length - 1]);
          } else {
            const segStart = path[segIndex];
            const segEnd = path[segIndex + 1];
            const segFrac = (moveDist - acc) / Math.max(segLengths[segIndex], 0.0001);
            const lat = segStart[0] + (segEnd[0] - segStart[0]) * segFrac;
            const lon = segStart[1] + (segEnd[1] - segStart[1]) * segFrac;
            mover.setLatLng([lat, lon]);
            label.setLatLng([lat, lon]);
          }
          label.setIcon(
            L.divIcon({
              className: "rail-label",
              html: `ETA ${minutesLeft.toFixed(1)}m`,
              iconSize: null
            })
          );
        }

        if (progress >= 1) {
          clearInterval(timer);
          simTimers = simTimers.filter((t) => t !== timer);
          label.setIcon(
            L.divIcon({
              className: "rail-label",
              html: "Arrived CBD",
              iconSize: null
            })
          );
        }
      }, 30);
      simTimers.push(timer);
    }

    map.on("click", (e) => {
      try {
        document.getElementById("status").textContent = `Click at ${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`;
        animateTravel(e.latlng);
      } catch (err) {
        ERROR_COUNT += 1;
        lastError = err.message || String(err);
        console.error(err);
        document.getElementById("status").textContent = "Error during simulation";
        document.getElementById("debug-path").textContent = `Errors: ${ERROR_COUNT} (last: ${lastError})`;
        updateDebugMeta();
      }
    });
    map.on("zoomstart", () => {
      pauseHeavyLayers();
      setBusy("Adjusting view…", true);
    });
    map.on("zoomend", () => {
      resumeHeavyLayers();
      setBusy("", false);
    });
    document.getElementById("panelToggle").addEventListener("click", () => {
      const p = document.querySelector(".panel");
      if (p) p.classList.toggle("hidden");
    });
  </script>
</body>
</html>
