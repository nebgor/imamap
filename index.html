<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Perth PT Commute Sketch</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <link
    rel="icon"
    href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="%230c172a"/><path d="M16 40c8-12 24-12 32 0" stroke="%237bdcb5" stroke-width="5" fill="none" stroke-linecap="round"/><circle cx="32" cy="24" r="6" fill="%2364b5ff"/></svg>'
  />
  <style>
    :root {
      --panel-bg: rgba(12, 16, 27, 0.9);
      --panel-text: #eaf3ff;
      --accent: #6fe7c9;
      --muted: #9fb1c7;
      --border: rgba(255, 255, 255, 0.14);
      --font: "Inter", system-ui, -apple-system, sans-serif;
      --rail: #64b5ff;
      --bg-1: #0b1020;
      --bg-2: #0f1a32;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at 35% 25%, #10213f 0%, #0b1228 50%, #080c1a 100%);
      font-family: var(--font);
      color: var(--panel-text);
      overflow: hidden;
    }
    #map {
      position: absolute;
      inset: 0;
      z-index: 0;
    }
    .panel {
      position: absolute;
      top: 14px;
      left: 14px;
      width: 340px;
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(6px);
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.22);
      z-index: 1200;
    }
    h1 {
      margin: 0 0 10px;
      font-size: 17px;
      letter-spacing: 0.4px;
      font-weight: 700;
      color: #e0fbff;
    }
    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .row label {
      flex: 1;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.06);
      color: var(--panel-text);
      font-size: 14px;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
      font-size: 13px;
      color: var(--muted);
    }
    button {
      padding: 9px 14px;
      border-radius: 12px;
      border: none;
      font-weight: 700;
      letter-spacing: 0.2px;
      background: linear-gradient(120deg, #4dd4a4, #5fb3ff);
      color: #04131e;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.18);
    }
    button:active {
      transform: translateY(1px);
    }
    .legend {
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
    }
    .legend-bar {
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(
        90deg,
        hsl(120, 75%, 45%),
        hsl(60, 80%, 52%),
        hsl(30, 85%, 55%),
        hsl(0, 80%, 50%)
      );
      border: 1px solid var(--border);
      margin: 6px 0 4px;
    }
    .legend-scale {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--muted);
    }
    .status {
      font-size: 12px;
      color: var(--muted);
    }
    .debug {
      position: absolute;
      bottom: 12px;
      left: 14px;
      background: rgba(8, 11, 20, 0.9);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      max-width: 460px;
      font-size: 12px;
      color: #cbd5e1;
      display: grid;
      gap: 4px;
      line-height: 1.4;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
      z-index: 1200;
    }
    .debug strong {
      color: #e2f3ff;
    }
    .rail-label {
      background: rgba(15, 102, 175, 0.5);
      color: #e7f6ff;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    .gallery {
      margin-top: 8px;
      border-top: 1px solid var(--border);
      padding-top: 8px;
      display: grid;
      gap: 6px;
    }
    .gallery h2 {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
    }
    .snapshots {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }
    .snapshot-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px;
      display: grid;
      gap: 4px;
    }
    .snapshot-card img {
      width: 100%;
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .snapshot-card button {
      width: 100%;
      padding: 6px 8px;
      background: rgba(255, 255, 255, 0.08);
      color: #d7e6ff;
      border-radius: 8px;
      font-weight: 600;
      box-shadow: none;
    }
    .snapshot-meta {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
    }
    @media (max-width: 600px) {
      .panel {
        width: calc(100% - 24px);
        left: 12px;
        right: 12px;
      }
      .row {
        flex-direction: column;
      }
      .debug {
        max-width: calc(100% - 24px);
        left: 12px;
        right: 12px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="panel">
    <h1>Perth PT commute sketch</h1>
    <div class="row">
      <label>Base wait (min)
        <input type="number" id="baseWait" value="8" min="0" step="1" />
      </label>
      <label>Network speed (km/h)
        <input type="number" id="netSpeed" value="40" min="1" step="1" />
      </label>
    </div>
    <div class="controls">
      <button id="recompute">Recompute</button>
      <button id="saveSnapshot">Save snapshot</button>
      <button id="simulateRandom">Simulate random</button>
      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="toggleRail" checked />
        Show rail lines
      </label>
    </div>
    <div class="legend">
      Commute minutes
      <div class="legend-bar"></div>
      <div class="legend-scale">
        <span>short</span><span>medium</span><span>long</span>
      </div>
    </div>
    <div class="status" id="status">Fetching stops…</div>
    <div class="gallery">
      <h2>Snapshots (cached locally)</h2>
      <div class="snapshots" id="snapshots"></div>
    </div>
  </div>
  <div class="debug" id="debug">
    <div><strong>Debug</strong> — ready</div>
    <div id="debug-meta"></div>
    <div id="debug-corridor"></div>
  </div>
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script
    src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"
    integrity="sha256-UeHt70RwwG8+dBSnupnXhZ2dEoWQWA31pLPVbRLCp6A="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
  <script>
    function buildRouteGraph(routes) {
      const nodes = new Map();
      const key = (lat, lon) => `${lat.toFixed(5)},${lon.toFixed(5)}`;
      function addEdge(a, b) {
        const ka = key(a[0], a[1]);
        const kb = key(b[0], b[1]);
        const d = haversine(a[0], a[1], b[0], b[1]);
        if (!nodes.has(ka)) nodes.set(ka, { lat: a[0], lon: a[1], edges: [] });
        if (!nodes.has(kb)) nodes.set(kb, { lat: b[0], lon: b[1], edges: [] });
        nodes.get(ka).edges.push({ k: kb, w: d });
        nodes.get(kb).edges.push({ k: ka, w: d });
      }
      routes.forEach((r) => {
        (r.paths || []).forEach((path) => {
          for (let i = 0; i < path.length - 1; i++) {
            addEdge(path[i], path[i + 1]);
          }
        });
      });
      return { nodes, routes };
    }

    function shortestPath(graph, start, goal) {
      const nodes = graph.nodes;
      const startKey = nearestNodeKey(nodes, start.lat, start.lon);
      const goalKey = nearestNodeKey(nodes, goal.lat, goal.lon);
      if (!startKey || !goalKey) return null;
      const dist = new Map();
      const prev = new Map();
      const pq = [];
      function push(k, d) {
        pq.push({ k, d });
        pq.sort((a, b) => a.d - b.d);
      }
      nodes.forEach((_, k) => dist.set(k, Infinity));
      dist.set(startKey, 0);
      push(startKey, 0);
      while (pq.length) {
        const { k } = pq.shift();
        if (k === goalKey) break;
        const n = nodes.get(k);
        if (!n) continue;
        n.edges.forEach((e) => {
          const alt = dist.get(k) + e.w;
          if (alt < dist.get(e.k)) {
            dist.set(e.k, alt);
            prev.set(e.k, k);
            push(e.k, alt + heuristic(nodes.get(e.k), nodes.get(goalKey)));
          }
        });
      }
      if (!prev.has(goalKey) && startKey !== goalKey) return null;
      const path = [];
      let u = goalKey;
      path.unshift(nodes.get(u));
      while (prev.has(u)) {
        u = prev.get(u);
        path.unshift(nodes.get(u));
      }
      return path.map((p) => [p.lat, p.lon]);
    }

    function heuristic(a, b) {
      return haversine(a.lat, a.lon, b.lat, b.lon);
    }

    function nearestNodeKey(nodes, lat, lon) {
      let best = null;
      let bestD = Infinity;
      nodes.forEach((v, k) => {
        const d = haversine(lat, lon, v.lat, v.lon);
        if (d < bestD) {
          bestD = d;
          best = k;
        }
      });
      return best;
    }
  </script>
  <script>
    const qs = new URLSearchParams(window.location.search);
    if (qs.get("status") === "json") {
      const heatLen = (() => {
        try {
          const v = localStorage.getItem("simHeatV1");
          return v ? JSON.parse(v).length : 0;
        } catch {
          return 0;
        }
      })();
      const stopLen = (() => {
        try {
          const v = localStorage.getItem("stopsCacheV1");
          if (!v) return 0;
          const p = JSON.parse(v);
          return (p.stops || []).length;
        } catch {
          return 0;
        }
      })();
      document.body.innerHTML = `<pre>${JSON.stringify(
        {
          status: "ok",
          timestamp: new Date().toISOString(),
          heatCount: heatLen,
          stopCacheCount: stopLen,
          note: "status-only mode; map not initialized"
        },
        null,
        2
      )}</pre>`;
      throw new Error("status-only-mode");
    }

    const target = { lat: -31.9523, lon: 115.8590 };
    const STOP_CACHE_KEY = "stopsCacheV1";
    const SNAPSHOT_CACHE_KEY = "snapshotsV1";
    const STOP_CACHE_MAX_AGE_HRS = 6;
    const ROUTE_CACHE_KEY = "routesCacheV1";
    const ROUTE_CACHE_MAX_AGE_HRS = 12;
    const map = L.map("map", { zoomControl: false }).setView([target.lat, target.lon], 11);
    L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors & Carto'
    }).addTo(map);
    L.control.zoom({ position: "bottomright" }).addTo(map);

    const stopsLayer = L.layerGroup().addTo(map);
    const railLayer = L.layerGroup().addTo(map);
    const stationLayer = L.layerGroup().addTo(map);
    const simLayer = L.layerGroup().addTo(map);
    const heatLineLayer = L.layerGroup().addTo(map);
    const heatVisLayer = L.heatLayer([], {
      radius: 18,
      blur: 12,
      maxZoom: 17,
      gradient: { 0.1: "#1e3a8a", 0.4: "#22d3ee", 0.7: "#facc15", 1.0: "#ef4444" }
    }).addTo(map);
    let simTimer = null;
    let routeGraph = null;

    const corridors = [
      // Mandurah line corridor
      [[-31.95, 115.86], [-32.0, 115.86], [-32.1, 115.86], [-32.18, 115.83], [-32.25, 115.8], [-32.35, 115.78], [-32.45, 115.75]],
      // Joondalup / Yanchep
      [[-31.95, 115.86], [-31.9, 115.84], [-31.83, 115.8], [-31.74, 115.75], [-31.63, 115.71], [-31.55, 115.7], [-31.48, 115.7]],
      // Fremantle
      [[-31.95, 115.86], [-31.99, 115.84], [-32.03, 115.8], [-32.05, 115.78]],
      // Midland
      [[-31.95, 115.86], [-31.92, 115.9], [-31.89, 115.95], [-31.87, 116.0], [-31.88, 116.05]],
      // Armadale / Thornlie
      [[-31.95, 115.86], [-32.0, 115.88], [-32.04, 115.92], [-32.08, 115.98], [-32.12, 116.02]],
      // Airport
      [[-31.95, 115.86], [-31.93, 115.89], [-31.92, 115.96], [-31.93, 116.0]],
      // Ellenbrook
      [[-31.95, 115.86], [-31.89, 115.91], [-31.85, 115.94], [-31.82, 115.97], [-31.78, 115.98]]
    ];

    const railLines = [
      {
        name: "Mandurah",
        points: [
          [-31.95, 115.86],
          [-31.97, 115.86],
          [-31.986, 115.857], // Elizabeth Quay
          [-32.021, 115.857], // South Perth-ish alignment
          [-32.049, 115.851], // Canning Bridge
          [-32.062, 115.849], // Bull Creek
          [-32.071, 115.848], // Murdoch
          [-32.103, 115.85], // Cockburn approach
          [-32.127, 115.85], // Cockburn Central
          [-32.15, 115.846], // Success
          [-32.175, 115.842], // Aubin Grove
          [-32.205, 115.834], // Kwinana industrial curve
          [-32.249, 115.822], // Rockingham
          [-32.279, 115.781], // Warnbro
          [-32.32, 115.766], // Karnup/Lakelands curve
          [-32.37, 115.754],
          [-32.45, 115.747] // Mandurah
        ]
      },
      {
        name: "Joondalup/Yanchep",
        points: [
          [-31.95, 115.86],
          [-31.936, 115.846], // Leederville
          [-31.917, 115.84], // Glendalough
          [-31.897, 115.81], // Stirling
          [-31.866, 115.8], // Warwick
          [-31.844, 115.782], // Greenwood
          [-31.819, 115.768], // Whitfords
          [-31.78, 115.756], // Edgewater
          [-31.746, 115.742], // Joondalup
          [-31.728, 115.735], // Currambine
          [-31.712, 115.732], // Clarkson
          [-31.689, 115.73], // Butler
          [-31.64, 115.71], // Alkimos
          [-31.58, 115.69], // Eglinton
          [-31.52, 115.69], // interim curve
          [-31.48, 115.7] // Yanchep
        ]
      },
      {
        name: "Fremantle",
        points: [
          [-31.95, 115.86],
          [-31.958, 115.853], // City West
          [-31.964, 115.842], // West Leederville
          [-31.97, 115.829], // Subi
          [-31.989, 115.79], // Claremont
          [-32.009, 115.756], // Cottesloe
          [-32.033, 115.752],
          [-32.053, 115.748] // Fremantle
        ]
      },
      {
        name: "Midland",
        points: [
          [-31.95, 115.86],
          [-31.948, 115.872], // McIver/Claisebrook
          [-31.94, 115.885],
          [-31.93, 115.9],
          [-31.914, 115.914], // Bayswater
          [-31.9, 115.967], // Guildford
          [-31.889, 116.005] // Midland
        ]
      },
      {
        name: "Armadale/Thornlie",
        points: [
          [-31.95, 115.86],
          [-31.961, 115.894], // Burswood
          [-31.98, 115.897], // Oats St
          [-32.0, 115.92],
          [-32.04, 115.93],
          [-32.061, 115.952], // Thornlie spur
          [-32.079, 115.999], // Gosnells
          [-32.12, 116.02] // Armadale approach
        ]
      },
      {
        name: "Airport",
        points: [
          [-31.95, 115.86],
          [-31.941, 115.882],
          [-31.93, 115.92], // Burswood/Belmont approach
          [-31.927, 115.949], // Redcliffe
          [-31.938, 115.967], // Airport Central
          [-31.941, 116.0] // High Wycombe
        ]
      },
      {
        name: "Ellenbrook",
        points: [
          [-31.95, 115.86],
          [-31.93, 115.89],
          [-31.91, 115.915], // Bayswater connection
          [-31.89, 115.93],
          [-31.865, 115.897], // Noranda
          [-31.846, 115.89], // Malaga
          [-31.824, 115.95], // Whiteman
          [-31.79, 115.965],
          [-31.776, 115.97] // Ellenbrook
        ]
      }
    ];

    const busRoutes = [
      {
        name: "Kwinana Fwy BUS",
        points: [
          [-32.25, 115.84],
          [-32.2, 115.84],
          [-32.15, 115.84],
          [-32.1, 115.84],
          [-32.05, 115.85],
          [-32.0, 115.86],
          [-31.97, 115.86],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Mitchell Fwy BUS",
        points: [
          [-31.48, 115.7],
          [-31.6, 115.71],
          [-31.65, 115.71],
          [-31.7, 115.72],
          [-31.75, 115.74],
          [-31.8, 115.76],
          [-31.85, 115.78],
          [-31.9, 115.82],
          [-31.93, 115.84],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Albany Hwy",
        points: [
          [-32.15, 116.02],
          [-32.12, 116.0],
          [-32.08, 115.98],
          [-32.04, 115.95],
          [-32.0, 115.92],
          [-31.98, 115.9],
          [-31.96, 115.89],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Wanneroo Rd",
        points: [
          [-31.72, 115.78],
          [-31.78, 115.79],
          [-31.82, 115.81],
          [-31.86, 115.82],
          [-31.9, 115.84],
          [-31.93, 115.85],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Great Eastern Hwy",
        points: [
          [-31.94, 116.01],
          [-31.92, 115.99],
          [-31.9, 115.96],
          [-31.9, 115.93],
          [-31.92, 115.89],
          [-31.93, 115.87],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Canning Hwy",
        points: [
          [-32.05, 115.84],
          [-32.04, 115.85],
          [-32.02, 115.85],
          [-31.99, 115.85],
          [-31.97, 115.855],
          [-31.95, 115.86]
        ]
      },
      {
        name: "Marmion/West Coast",
        points: [
          [-31.55, 115.74],
          [-31.6, 115.75],
          [-31.65, 115.76],
          [-31.7, 115.77],
          [-31.75, 115.78],
          [-31.8, 115.79],
          [-31.84, 115.8],
          [-31.88, 115.81],
          [-31.92, 115.83],
          [-31.95, 115.86]
        ]
      }
    ];

    const railStations = [
      // Core CBD
      { name: "Perth Station", lat: -31.9516, lon: 115.8605 },
      { name: "Perth Underground", lat: -31.9524, lon: 115.8579 },
      { name: "Elizabeth Quay", lat: -31.9563, lon: 115.8543 },
      // Mandurah line
      { name: "Canning Bridge", lat: -32.0494, lon: 115.8517 },
      { name: "Bull Creek", lat: -32.064, lon: 115.852 },
      { name: "Murdoch", lat: -32.071, lon: 115.85 },
      { name: "Cockburn Central", lat: -32.1267, lon: 115.85 },
      { name: "Aubin Grove", lat: -32.175, lon: 115.843 },
      { name: "Rockingham", lat: -32.2745, lon: 115.73 },
      { name: "Mandurah", lat: -32.536, lon: 115.742 },
      // Joondalup / Yanchep
      { name: "Leederville", lat: -31.9361, lon: 115.8414 },
      { name: "Glendalough", lat: -31.917, lon: 115.84 },
      { name: "Stirling", lat: -31.8962, lon: 115.8097 },
      { name: "Warwick", lat: -31.8592, lon: 115.807 },
      { name: "Whitfords", lat: -31.811, lon: 115.767 },
      { name: "Joondalup", lat: -31.744, lon: 115.768 },
      { name: "Butler", lat: -31.639, lon: 115.71 },
      { name: "Yanchep", lat: -31.55, lon: 115.69 },
      // Fremantle
      { name: "Subiaco", lat: -31.95, lon: 115.817 },
      { name: "Claremont", lat: -31.986, lon: 115.781 },
      { name: "Cottesloe", lat: -32.009, lon: 115.756 },
      { name: "Fremantle", lat: -32.053, lon: 115.748 },
      // Midland
      { name: "Claisebrook", lat: -31.9503, lon: 115.8735 },
      { name: "Bayswater", lat: -31.9147, lon: 115.9136 },
      { name: "Guildford", lat: -31.9, lon: 115.967 },
      { name: "Midland", lat: -31.889, lon: 116.005 },
      // Armadale / Thornlie
      { name: "Burswood", lat: -31.961, lon: 115.894 },
      { name: "Oats Street", lat: -31.9805, lon: 115.8974 },
      { name: "Thornlie", lat: -32.0618, lon: 115.9521 },
      { name: "Gosnells", lat: -32.079, lon: 115.999 },
      { name: "Armadale", lat: -32.153, lon: 116.016 },
      // Airport
      { name: "Redcliffe", lat: -31.927, lon: 115.949 },
      { name: "Airport Central", lat: -31.938, lon: 115.967 },
      { name: "High Wycombe", lat: -31.9405, lon: 116.007 },
      // Ellenbrook
      { name: "Bayswater (Ellenbrook)", lat: -31.9147, lon: 115.9136 },
      { name: "Noranda", lat: -31.865, lon: 115.897 },
      { name: "Malaga", lat: -31.846, lon: 115.89 },
      { name: "Whiteman Park", lat: -31.824, lon: 115.95 },
      { name: "Ellenbrook", lat: -31.776, lon: 115.97 }
    ];

    const hillsZone = { latMin: -32.05, latMax: -31.75, lonMin: 116.0, lonMax: 116.2 };

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = (d) => (d * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function pointSegmentDistance(p, a, b) {
      const toRad = (d) => (d * Math.PI) / 180;
      const latScale = 111;
      const x1 = (a[1] - p[1]) * Math.cos(toRad((a[0] + p[0]) / 2)) * latScale;
      const y1 = (a[0] - p[0]) * latScale;
      const x2 = (b[1] - p[1]) * Math.cos(toRad((b[0] + p[0]) / 2)) * latScale;
      const y2 = (b[0] - p[0]) * latScale;
      const dot = x1 * x2 + y1 * y2;
      const lenSq = x2 * x2 + y2 * y2;
      const t = Math.max(0, Math.min(1, lenSq === 0 ? 0 : dot / lenSq));
      const projX = t * x2;
      const projY = t * y2;
      const dx = projX - x1;
      const dy = projY - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function corridorFactor(lat, lon) {
      let factor = 1;
      corridors.forEach((line) => {
        for (let i = 0; i < line.length - 1; i++) {
          const d = pointSegmentDistance([lat, lon], line[i], line[i + 1]);
          if (d < 1.5) {
            factor = Math.min(factor, 0.78 + d * 0.05);
          }
        }
      });
      if (
        lat >= hillsZone.latMin &&
        lat <= hillsZone.latMax &&
        lon >= hillsZone.lonMin &&
        lon <= hillsZone.lonMax
      ) {
        factor *= 1.12;
      }
      return factor;
    }

    function colourForMinutes(mins) {
      const clamped = Math.max(0, Math.min(90, mins));
      const ratio = clamped / 90;
      const hue = 120 - ratio * 120;
      const sat = 80;
      const light = 50 + ratio * 5;
      return `hsl(${hue}, ${sat}%, ${light}%)`;
    }

    function computeCommute(stop, baseWait, netSpeed) {
      const distanceKm = haversine(stop.lat, stop.lon, target.lat, target.lon);
      const corridor = corridorFactor(stop.lat, stop.lon);
      const effectiveSpeed = netSpeed * (1 / corridor);
      const rideMins = (distanceKm / Math.max(effectiveSpeed, 1)) * 60;
      return baseWait + rideMins;
    }

    function renderRailLines(show) {
      railLayer.clearLayers();
      stationLayer.clearLayers();
      if (!show) return;
      railLines.forEach((line) => {
        const poly = L.polyline(line.points, {
          color: "var(--rail)",
          weight: 4,
          opacity: 0.8,
          dashArray: "4 6"
        }).addTo(railLayer);
        const midpoint = line.points[Math.floor(line.points.length / 2)];
        L.marker(midpoint, {
          interactive: false,
          icon: L.divIcon({
            className: "rail-label",
            html: line.name,
            iconSize: null
          })
        }).addTo(railLayer);
      });
      railStations.forEach((st) => {
        L.circleMarker([st.lat, st.lon], {
          radius: 5,
          color: "#0b1220",
          weight: 1,
          fillColor: "#ffffff",
          fillOpacity: 0.9
        })
          .bindTooltip(st.name, { permanent: false, direction: "top", offset: [0, -4] })
          .addTo(stationLayer);
      });
    }

    function renderStops(stops, baseWait, netSpeed) {
      stopsLayer.clearLayers();
      const majorPattern = /(station|busport|interchange|terminus|bus station)/i;
      stops.forEach((stop) => {
        const commute = computeCommute(stop, baseWait, netSpeed);
        const color = colourForMinutes(commute);
        const isMajor = majorPattern.test(stop.stopname || "");
        L.circleMarker([stop.lat, stop.lon], {
          radius: isMajor ? 8 : 5.5,
          color: isMajor ? "#d9f99d" : "#0d1b2a",
          weight: 1,
          fillColor: color,
          fillOpacity: 0.9
        })
          .bindPopup(
            `<strong>${stop.stopname || "Stop"}</strong><br>ID: ${stop.stopid}<br>${commute.toFixed(1)} min`
          )
          .addTo(stopsLayer);
      });
      document.getElementById("status").textContent = `Rendered ${stops.length} stops`;
      const debugMeta = document.getElementById("debug-meta");
      debugMeta.textContent = `Stops: ${stops.length} · Base wait: ${baseWait} min · Speed: ${netSpeed} km/h`;
    }

    function readStopCache() {
      const cached = localStorage.getItem(STOP_CACHE_KEY);
      if (!cached) return null;
      try {
        const parsed = JSON.parse(cached);
        const ageHours = (Date.now() - parsed.ts) / 36e5;
        if (ageHours > STOP_CACHE_MAX_AGE_HRS) return null;
        return parsed.stops;
      } catch {
        return null;
      }
    }

    function writeStopCache(stops) {
      localStorage.setItem(STOP_CACHE_KEY, JSON.stringify({ ts: Date.now(), stops }));
    }

    function readRouteCache() {
      const cached = localStorage.getItem(ROUTE_CACHE_KEY);
      if (!cached) return null;
      try {
        const parsed = JSON.parse(cached);
        const ageHours = (Date.now() - parsed.ts) / 36e5;
        if (ageHours > ROUTE_CACHE_MAX_AGE_HRS) return null;
        return parsed.routes;
      } catch {
        return null;
      }
    }

    function writeRouteCache(routes) {
      localStorage.setItem(ROUTE_CACHE_KEY, JSON.stringify({ ts: Date.now(), routes }));
    }

    async function fetchRoutes(bbox) {
      const status = document.getElementById("status");
      const cached = readRouteCache();
      if (cached) {
        return cached;
      }
      const [minLat, minLon, maxLat, maxLon] = bbox;
      status.textContent = "Fetching routes…";
      const url =
        "https://services.slip.wa.gov.au/public/rest/services/SLIP_Public_Services/Transport/MapServer/15/query" +
        "?where=1%3D1" +
        "&outFields=route_name,route_number" +
        `&geometry=${minLon},${minLat},${maxLon},${maxLat}` +
        "&geometryType=esriGeometryEnvelope" +
        "&inSR=4326&spatialRel=esriSpatialRelIntersects" +
        "&outSR=4326&f=json";
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`Failed to fetch routes: ${res.status}`);
      }
      const data = await res.json();
      const routes = (data.features || [])
        .map((f) => ({
          name: f.attributes.route_name || f.attributes.route_number || "route",
          paths: f.geometry.paths || []
        }))
        .filter((r) => r.paths.length > 0);
      if (routes.length) {
        writeRouteCache(routes);
      }
      status.textContent = `Routes loaded (${routes.length})`;
      return routes;
    }

    async function fetchStops() {
      const status = document.getElementById("status");
      const cached = readStopCache();
      if (cached) {
        status.textContent = `Loaded ${cached.length} stops from cache`;
        return cached;
      }
      status.textContent = "Fetching stops…";
      const url =
        "https://services.slip.wa.gov.au/public/rest/services/SLIP_Public_Services/Transport_Public_PT_Stops/FeatureServer/14/query" +
        "?where=1%3D1" +
        "&outFields=stopid,stopname" +
        "&geometry=-32.6,115.5,-31.4,116.2" +
        "&geometryType=esriGeometryEnvelope" +
        "&inSR=4326&spatialRel=esriSpatialRelIntersects" +
        "&outSR=4326&f=json";
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`Failed to fetch stops: ${res.status}`);
      }
      const data = await res.json();
      const stops = (data.features || [])
        .map((f) => ({
          stopid: f.attributes.stopid,
          stopname: f.attributes.stopname,
          lat: f.geometry.y,
          lon: f.geometry.x
        }))
        .filter((s) => s.lat && s.lon);
      status.textContent = `Loaded ${stops.length} stops`;
      writeStopCache(stops);
      return stops;
    }

    function sampleCorridorDebug(lat, lon) {
      const factor = corridorFactor(lat, lon);
      const mins = computeCommute({ lat, lon }, Number(baseWait.value), Number(netSpeed.value));
      return { factor, mins };
    }

    async function init() {
      try {
        const stops = await fetchStops();
        window.__stops = stops;
        renderStops(stops, Number(baseWait.value), Number(netSpeed.value));
        renderRailLines(toggleRail.checked);
        // prefetch metro routes
        const routes = await fetchRoutes([-32.6, 115.5, -31.4, 116.2]);
        routeGraph = buildRouteGraph(routes);
        const dbg = sampleCorridorDebug(-31.96, 115.86);
        document.getElementById("debug-corridor").textContent = `CBD sample corridor factor: ${dbg.factor.toFixed(2)} · est ${dbg.mins.toFixed(1)} min`;
        document.getElementById("debug").firstElementChild.textContent = "Debug — ok";
      } catch (e) {
        document.getElementById("status").textContent = e.message;
        document.getElementById("debug").firstElementChild.textContent = `Debug — ${e.message}`;
        console.error(e);
      }
    }

    document.getElementById("recompute").addEventListener("click", () => {
      if (!window.__stops) return;
      renderStops(window.__stops, Number(baseWait.value), Number(netSpeed.value));
    });
    document.getElementById("toggleRail").addEventListener("change", (e) => {
      renderRailLines(e.target.checked);
    });

    function loadSnapshots() {
      const raw = localStorage.getItem(SNAPSHOT_CACHE_KEY);
      if (!raw) return [];
      try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function saveSnapshots(list) {
      localStorage.setItem(SNAPSHOT_CACHE_KEY, JSON.stringify(list));
    }

    function renderSnapshots() {
      const container = document.getElementById("snapshots");
      container.innerHTML = "";
      const snaps = loadSnapshots();
      snaps.forEach((snap) => {
        const card = document.createElement("div");
        card.className = "snapshot-card";
        const img = document.createElement("img");
        img.src = snap.dataUrl;
        img.alt = "Map snapshot";
        card.appendChild(img);
        const meta = document.createElement("div");
        meta.className = "snapshot-meta";
        meta.textContent = `${new Date(snap.ts).toLocaleString()} · z${snap.zoom}`;
        card.appendChild(meta);
        const btn = document.createElement("button");
        btn.textContent = "Load view";
        btn.onclick = () => {
          map.setView([snap.center.lat, snap.center.lon], snap.zoom);
          if (window.__stops) {
            renderStops(window.__stops, snap.baseWait, snap.netSpeed);
          }
        };
        card.appendChild(btn);
        const del = document.createElement("button");
        del.textContent = "Delete";
        del.onclick = () => {
          const next = loadSnapshots().filter((s) => s.id !== snap.id);
          saveSnapshots(next);
          renderSnapshots();
        };
        card.appendChild(del);
        container.appendChild(card);
      });
    }

    document.getElementById("saveSnapshot").addEventListener("click", () => {
      if (!window.leafletImage) {
        alert("Snapshot helper not loaded yet.");
        return;
      }
      leafletImage(map, (err, canvas) => {
        if (err) {
          alert("Snapshot failed");
          return;
        }
        const dataUrl = canvas.toDataURL("image/png");
        const snaps = loadSnapshots();
        const snap = {
          id: crypto.randomUUID(),
          ts: Date.now(),
          dataUrl,
          center: { lat: map.getCenter().lat, lon: map.getCenter().lng },
          zoom: map.getZoom(),
          baseWait: Number(baseWait.value),
          netSpeed: Number(netSpeed.value)
        };
        snaps.unshift(snap);
        const trimmed = snaps.slice(0, 6);
        saveSnapshots(trimmed);
        renderSnapshots();
      });
    });

    function loadHeat() {
      const raw = localStorage.getItem("simHeatV1");
      if (!raw) return [];
      try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function saveHeat(list) {
      localStorage.setItem("simHeatV1", JSON.stringify(list));
    }

    function renderHeat() {
      heatLineLayer.clearLayers();
      const heat = loadHeat();
      const heatPoints = [];
      heat.forEach((h) => {
        L.polyline(h.path, {
          color: h.color,
          weight: 2,
          opacity: 0.18
        }).addTo(heatLineLayer);
        const sampled = samplePath(h.path);
        sampled.forEach((p) => heatPoints.push([p[0], p[1], h.weight]));
      });
      heatVisLayer.setLatLngs(heatPoints);
    }

    function samplePath(path) {
      const pts = [];
      for (let i = 0; i < path.length - 1; i++) {
        const a = path[i];
        const b = path[i + 1];
        const seg = haversine(a[0], a[1], b[0], b[1]);
        const steps = Math.max(1, Math.floor(seg / 0.35)); // sample roughly every 350m
        for (let s = 0; s <= steps; s++) {
          const t = s / steps;
          pts.push([a[0] + (b[0] - a[0]) * t, a[1] + (b[1] - a[1]) * t]);
        }
      }
      return pts;
    }

    function addHeatPath(path, minutes) {
      const heat = loadHeat();
      const color = colourForMinutes(minutes);
      const weight = Math.min(1, Math.max(0.2, minutes / 90));
      heat.unshift({ path, color, ts: Date.now(), weight });
      const trimmed = heat.slice(0, 200);
      saveHeat(trimmed);
      renderHeat();
    }

    function simulateRandom(count = 20) {
      const bounds = { minLat: -32.6, maxLat: -31.4, minLon: 115.5, maxLon: 116.2 };
      for (let i = 0; i < count; i++) {
        const lat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
        const lon = bounds.minLon + Math.random() * (bounds.maxLon - bounds.minLon);
        const travel = buildTravelPath({ lat, lng: lon });
        if (travel) {
          const base = Number(baseWait.value);
          const speed = Number(netSpeed.value);
          const commute = computeCommute(travel.near.stop, base, speed);
          addHeatPath(travel.path, commute);
        }
      }
    }

    document.getElementById("simulateRandom").addEventListener("click", () => {
      simulateRandom(25);
    });

    renderSnapshots();
    renderHeat();
    init().then(() => {
      // seed a small batch if no heat is cached
      if (!loadHeat().length) {
        simulateRandom(15);
      }
    });

    function nearestStop(lat, lon) {
      if (!window.__stops) return null;
      let best = null;
      let bestDist = Infinity;
      window.__stops.forEach((s) => {
        const d = haversine(lat, lon, s.lat, s.lon);
        if (d < bestDist) {
          bestDist = d;
          best = s;
        }
      });
      return { stop: best, distKm: bestDist };
    }

    function nearestPointIndex(points, lat, lon) {
      let idx = 0;
      let best = Infinity;
      points.forEach((p, i) => {
        const d = haversine(lat, lon, p[0], p[1]);
        if (d < best) {
          best = d;
          idx = i;
        }
      });
      return { idx, distKm: best };
    }

    function bestLineForStop(stop) {
      let winner = null;
      railLines.forEach((line) => {
        const nearStop = nearestPointIndex(line.points, stop.lat, stop.lon);
        if (!winner || nearStop.distKm < winner.stopDist) {
          const nearCbd = nearestPointIndex(line.points, target.lat, target.lon);
          winner = {
            line,
            stopIdx: nearStop.idx,
            stopDist: nearStop.distKm,
            cbdIdx: nearCbd.idx,
            cbdDist: nearCbd.distKm
          };
        }
      });
      return winner;
    }

    function bestBusRouteForStop(stop) {
      let winner = null;
      const sources = [];
      if (routeGraph && routeGraph.routes) {
        routeGraph.routes.forEach((r) => sources.push({ dynamic: true, route: r }));
      }
      busRoutes.forEach((r) => sources.push({ dynamic: false, route: { name: r.name, paths: [r.points] } }));
      sources.forEach((src) => {
        src.route.paths.forEach((pts) => {
          const nearStop = nearestPointIndex(pts, stop.lat, stop.lon);
          const nearCbd = nearestPointIndex(pts, target.lat, target.lon);
          const span = Math.abs(nearStop.idx - nearCbd.idx);
          if (!winner || nearStop.distKm < winner.stopDist) {
            winner = {
              route: src.route,
              stopIdx: nearStop.idx,
              stopDist: nearStop.distKm,
              cbdIdx: nearCbd.idx,
              cbdDist: nearCbd.distKm,
              span,
              points: pts
            };
          }
        });
      });
      return winner;
    }

    function buildTravelPath(clickLatLng) {
      if (!window.__stops) return null;
      const near = nearestStop(clickLatLng.lat, clickLatLng.lng);
      if (!near.stop) return null;

      const path = [];
      path.push([clickLatLng.lat, clickLatLng.lng]);
      path.push([near.stop.lat, near.stop.lon]);

      const railChoice = bestLineForStop(near.stop);
      const busChoice = bestBusRouteForStop(near.stop);

      function buildCorridor(choice, points) {
        const linePoints = points;
        const stopIdx = choice.stopIdx;
        const cbdIdx = choice.cbdIdx;
        path.push(linePoints[stopIdx]);
        const slice =
          stopIdx <= cbdIdx ? linePoints.slice(stopIdx, cbdIdx + 1) : linePoints.slice(cbdIdx, stopIdx + 1).reverse();
        slice.forEach((p) => {
          const last = path[path.length - 1];
          if (!(last[0] === p[0] && last[1] === p[1])) path.push(p);
        });
      }

      const railSpan = railChoice ? Math.abs(railChoice.stopIdx - railChoice.cbdIdx) : Infinity;
      const busSpan = busChoice ? Math.abs(busChoice.stopIdx - busChoice.cbdIdx) : Infinity;

      if (busChoice && busSpan <= railSpan) {
        buildCorridor(busChoice, busChoice.points);
      } else if (railChoice) {
        buildCorridor(railChoice, railChoice.line.points);
      }

      path.push([target.lat, target.lon]);
      return { path, near, railChoice, busChoice };
    }

    function animateTravel(clickLatLng) {
      if (!window.__stops) return;
      simLayer.clearLayers();
      if (simTimer) {
        clearInterval(simTimer);
        simTimer = null;
      }

      const travel = buildTravelPath(clickLatLng);
      if (!travel) return;
      const { path, near } = travel;
      // persist heat contribution for this click
      const base = Number(baseWait.value);
      const speed = Number(netSpeed.value);
      const commute = computeCommute(near.stop, base, speed);
      addHeatPath(path, commute);

      const waitRatio = Math.min(0.6, base / Math.max(commute, 0.1));
      const totalSec = Math.max(4, Math.min(10, commute / 8)); // scale visual time

      const segLengths = [];
      let totalLen = 0;
      for (let i = 0; i < path.length - 1; i++) {
        const seg = haversine(path[i][0], path[i][1], path[i + 1][0], path[i + 1][1]);
        segLengths.push(seg);
        totalLen += seg;
      }

      const routeLine = L.polyline(path, { color: "#94a3b8", weight: 3, opacity: 0.6 }).addTo(simLayer);

      const startMarker = L.circleMarker(path[0], { radius: 5, color: "#38bdf8", fillColor: "#38bdf8", fillOpacity: 0.8 }).addTo(simLayer);
      startMarker.bindTooltip("Clicked origin", { direction: "top", offset: [0, -4], permanent: false });
      const stopMarker = L.circleMarker(path[1], { radius: 7, color: "#f97316", fillColor: "#f97316", fillOpacity: 0.9 }).addTo(simLayer);
      stopMarker.bindTooltip(`Nearest stop: ${near.stop.stopname || near.stop.stopid}`, { direction: "top", offset: [0, -4], permanent: false });

      const mover = L.circleMarker(path[1], { radius: 6, color: "#f59e0b", fillColor: "#f59e0b", fillOpacity: 0.95 }).addTo(simLayer);
      const label = L.marker(path[1], {
        icon: L.divIcon({
          className: "rail-label",
          html: "",
          iconSize: null
        })
      }).addTo(simLayer);

      const startTs = performance.now();
      simTimer = setInterval(() => {
        const elapsed = (performance.now() - startTs) / 1000;
        const progress = Math.min(1, elapsed / totalSec);
        const minutesUsed = progress * commute;
        const minutesLeft = Math.max(0, commute - minutesUsed);

        if (progress < waitRatio) {
          mover.setLatLng(path[1]);
          label.setLatLng(path[1]);
          label.setIcon(
            L.divIcon({
              className: "rail-label",
              html: `Waiting… ${minutesLeft.toFixed(1)}m`,
              iconSize: null
            })
          );
        } else {
          const moveProgress = (progress - waitRatio) / (1 - waitRatio);
          const moveDist = moveProgress * totalLen;
          let acc = 0;
          let segIndex = 0;
          while (segIndex < segLengths.length && acc + segLengths[segIndex] < moveDist) {
            acc += segLengths[segIndex];
            segIndex++;
          }
          if (segIndex >= segLengths.length) {
            mover.setLatLng(path[path.length - 1]);
            label.setLatLng(path[path.length - 1]);
          } else {
            const segStart = path[segIndex];
            const segEnd = path[segIndex + 1];
            const segFrac = (moveDist - acc) / Math.max(segLengths[segIndex], 0.0001);
            const lat = segStart[0] + (segEnd[0] - segStart[0]) * segFrac;
            const lon = segStart[1] + (segEnd[1] - segStart[1]) * segFrac;
            mover.setLatLng([lat, lon]);
            label.setLatLng([lat, lon]);
          }
          label.setIcon(
            L.divIcon({
              className: "rail-label",
              html: `ETA ${minutesLeft.toFixed(1)}m`,
              iconSize: null
            })
          );
        }

        if (progress >= 1) {
          clearInterval(simTimer);
          simTimer = null;
          label.setIcon(
            L.divIcon({
              className: "rail-label",
              html: "Arrived CBD",
              iconSize: null
            })
          );
        }
      }, 30);
    }

    map.on("click", (e) => {
      animateTravel(e.latlng);
    });
  </script>
</body>
</html>
